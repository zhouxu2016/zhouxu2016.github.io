{"meta":{"title":"ZhouXu'Blog","subtitle":null,"description":"NEVER GIVE UP;","author":"zhouxu","url":"https://zhouxu2016.github.io"},"pages":[{"title":"about","date":"2017-11-06T13:36:50.000Z","updated":"2017-11-09T12:31:53.904Z","comments":false,"path":"about/index.html","permalink":"https://zhouxu2016.github.io/about/index.html","excerpt":"","text":"Java开发工程师 互联网金融,微服务架构 © Copyright Hand China Co.Ltd"},{"title":"Categories","date":"2017-11-09T08:32:40.635Z","updated":"2017-11-09T08:32:40.635Z","comments":false,"path":"categories/index.html","permalink":"https://zhouxu2016.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-09T08:32:27.905Z","updated":"2017-11-09T08:32:27.905Z","comments":false,"path":"tags/index.html","permalink":"https://zhouxu2016.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ConcurrentHashMap的简单使用","slug":"ConcurrentHashMap","date":"2017-11-27T13:34:55.975Z","updated":"2017-11-27T14:24:36.695Z","comments":true,"path":"2017/11/27/ConcurrentHashMap/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/27/ConcurrentHashMap/","excerpt":"ConcurrentHashMap的介绍ConcurrentHashMap是一个线程安全，并且是一个高效的HashMap,ConcurrentMap，它是一个接口，是一个能够支持并发访问的java.util.map集合,在原有java.util.map接口基础上又新提供了4种方法，进一步扩展了原有Map的功能 1234567891011121314public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; //插入元素 V putIfAbsent(K key, V value); //移除元素 boolean remove(Object key, Object value); //替换元素 boolean replace(K key, V oldValue, V newValue); //替换元素 V replace(K key, V value);&#125; (1). putIfAbsent: 与原有put方法不同的是,putIfAbsent方法中如果插入的key相同,则不替换原有的value值 (2). remove: 与原有remove方法不同的是,新remove方法中增加了对value的判断,如果要删除的key–value不能与Map中原有的key–value对应上,则不会删除该元素 (3). replace(K,V,V): 增加了对value值的判断,如果key–oldValue能与Map中原有的key–value对应上,才进行替换操作 (4). replace(K,V): 与上面的replace不同的是,此replace不会对Map中原有的key–value进行比较,如果key存在则直接替换","text":"ConcurrentHashMap的介绍ConcurrentHashMap是一个线程安全，并且是一个高效的HashMap,ConcurrentMap，它是一个接口，是一个能够支持并发访问的java.util.map集合,在原有java.util.map接口基础上又新提供了4种方法，进一步扩展了原有Map的功能 1234567891011121314public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; //插入元素 V putIfAbsent(K key, V value); //移除元素 boolean remove(Object key, Object value); //替换元素 boolean replace(K key, V oldValue, V newValue); //替换元素 V replace(K key, V value);&#125; (1). putIfAbsent: 与原有put方法不同的是,putIfAbsent方法中如果插入的key相同,则不替换原有的value值 (2). remove: 与原有remove方法不同的是,新remove方法中增加了对value的判断,如果要删除的key–value不能与Map中原有的key–value对应上,则不会删除该元素 (3). replace(K,V,V): 增加了对value值的判断,如果key–oldValue能与Map中原有的key–value对应上,才进行替换操作 (4). replace(K,V): 与上面的replace不同的是,此replace不会对Map中原有的key–value进行比较,如果key存在则直接替换 12345678910111213141516171819202122232425262728 private static Logger log = Logger.getLogger(ConcurrentMapDemo.class); @Test public void test() &#123; ConcurrentHashMap&lt;Object, Object&gt; concurrentHashMap = new ConcurrentHashMap&lt;Object, Object&gt;(); concurrentHashMap.put(\"name\", \"tom\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString());// putIfAbsent: 与原有put方法不同的是,putIfAbsent方法中如果插入的key相同,则不替换原有的value值 concurrentHashMap.putIfAbsent(\"name\", \"lucy\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString());// remove: 与原有remove方法不同的是,新remove方法中增加了对value的判断,如果要删除的key--value不能与Map中原有的key--value对应上,// 则不会删除该元素 concurrentHashMap.remove(\"name\", \"lucy\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString());// replace(K,V,V): 增加了对value值的判断,如果key--oldValue能与Map中原有的key--value对应上,才进行替换操作 concurrentHashMap.replace(\"name\", \"lucy\", \"newLucy\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString());// replace(K,V): 与上面的replace不同的是,此replace不会对Map中原有的key--value进行比较,如果key存在则直接替换 concurrentHashMap.replace(\"name\", \"lucy\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString()); &#125; 其实,对于ConcurrentMap来说,我们更关注Map本身的操作,在并发情况下是如何实现数据安全的。在java.util.concurrent包中,ConcurrentMap的实现类主要以ConcurrentHashMap为主,接下来,我们具体来看下 从线程安全的角度来说,HashTable已经是一个线程安全的HashMap,说起ConcurrentHashMap,就不得不先提及下HashMap在线程不安全的表现 HashMap遍历删除HashMap或者ArrayList边遍历边删除数据会报java.util.ConcurrentModificationException异常 12345678910111213141516171819@Testpublic void test() &#123; Map&lt;Long, String&gt; mReqPacket = new HashMap&lt;Long, String&gt;(); for (long i = 0; i &lt; 15; i++) &#123; mReqPacket.put(i, i + \"\"); &#125; for (Entry&lt;Long, String&gt; entry : mReqPacket.entrySet()) &#123; long key = entry.getKey(); String value = entry.getValue(); if (key &lt; 10) &#123; mReqPacket.remove(key); &#125; &#125; for (Entry&lt;Long, String&gt; entry : mReqPacket.entrySet()) &#123; log.info(entry.getKey() + \" \" + entry.getValue()); &#125;&#125; 使用迭代器删除元素： 12345678910111213141516171819@Testpublic void test() &#123; Map&lt;Long, String&gt; mReqPacket = new HashMap&lt;Long, String&gt;(); for (long i = 0; i &lt; 15; i++) &#123; mReqPacket.put(i, i + \"\"); &#125; for (Iterator&lt;Entry&lt;Long, String&gt;&gt; iterator = mReqPacket.entrySet().iterator(); iterator.hasNext();) &#123; Entry&lt;Long, String&gt; entry = iterator.next(); long key = entry.getKey(); if (key &lt; 10) &#123; iterator.remove(); &#125; &#125; for (Entry&lt;Long, String&gt; entry : mReqPacket.entrySet()) &#123; log.info(entry.getKey() + \" \" + entry.getValue()); &#125;&#125; ConcurrentHashMap允许一边更新、一边遍历，也就是说在Iterator对象遍历的时候，ConcurrentHashMap也可以进行remove,put操作，且遍历的数据会随着remove,put操作产出变化 123456789101112131415161718@Testpublic void test1() &#123; Map&lt;Long, String&gt; conMap = new ConcurrentHashMap&lt;Long, String&gt;(); for (long i = 0; i &lt; 15; i++) &#123; conMap.put(i, i + \"\"); &#125; for (Entry&lt;Long, String&gt; entry : conMap.entrySet()) &#123; long key = entry.getKey(); if (key &lt; 10) &#123; conMap.remove(key); &#125; &#125; for (Entry&lt;Long, String&gt; entry : conMap.entrySet()) &#123; log.info(entry.getKey() + \" \" + entry.getValue()); &#125;&#125; ConcurrentHashMap多线程操作对ConcurrentHashMap边遍历边删除或者增加操作不会产生异常(可以不用迭代方式删除元素)，因为其内部已经做了维护，遍历的时候都能获得最新的值。即便是多个线程一起删除、添加元素也没问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344static Map&lt;Long, String&gt; conMap = new ConcurrentHashMap&lt;Long, String&gt;();public static void main(String[] args) throws InterruptedException &#123; for (long i = 0; i &lt; 5; i++) &#123; conMap.put(i, i + \"\"); &#125; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; for (Iterator&lt;Entry&lt;Long, String&gt;&gt; iterator = conMap.entrySet().iterator(); iterator.hasNext();) &#123; Map.Entry&lt;Long, String&gt; entry = iterator.next(); log.info(entry.getKey() + \" - \" + entry.getValue()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; conMap.put(100l, \"100\"); log.info(\"ADD:\" + 100); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); thread2.start(); Thread.sleep(3000); log.info(\"--------\"); for (Map.Entry&lt;Long, String&gt; entry : conMap.entrySet()) &#123; log.info(entry.getKey() + \" \" + entry.getValue()); &#125;&#125; 输出结果 123456789101112131415162017-11-27 22:03:45,123 [Thread-0] INFO [map.ConcurrentMapDemo] - 0 - 02017-11-27 22:03:45,123 [Thread-1] INFO [map.ConcurrentMapDemo] - ADD:1002017-11-27 22:03:45,248 [Thread-0] INFO [map.ConcurrentMapDemo] - 1 - 12017-11-27 22:03:45,357 [Thread-0] INFO [map.ConcurrentMapDemo] - 2 - 22017-11-27 22:03:45,466 [Thread-0] INFO [map.ConcurrentMapDemo] - 3 - 32017-11-27 22:03:45,575 [Thread-0] INFO [map.ConcurrentMapDemo] - 4 - 42017-11-27 22:03:45,685 [Thread-0] INFO [map.ConcurrentMapDemo] - 100 - 1002017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - --------2017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 0 02017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 1 12017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 2 22017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 3 32017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 4 42017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 100 100Process finished with exit code 0 ConcurrentHashMap结构我们来了解下ConcurrentHashMap的整体结构，这样有利于我们快速理解源码。我们就在此进行回顾下 HashMap的整体结构 HashMap底层使用数组和链表，实现哈希表结构。插入的元素通过散列的形式分布到数组的各个角标下；当有重复的散列值时，便将新增的元素插入在链表头部，使其形成链表结构，依次向后排列。 下面是，ConcurrentHashMap的结构: 与HashMap不同的是，ConcurrentHashMap中多了一层数组结构，由Segment和HashEntry两个数组组成。其中Segment起到了加锁同步的作用，而HashEntry则起到了存储K.V键值对的作用 在ConcurrentHashMap中，每一个ConcurrentHashMap都包含了一个Segment数组，在Segment数组中每一个Segment对象则又包含了一个HashEntry数组，而在HashEntry数组中，每一个HashEntry对象保存K-V数据的同时又形成了链表结构，此时与HashMap结构相同 12345678910111213141516171819202122232425262728293031323334private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // For serialization compatibility // Emulate segment calculation from previous version of this class int sshift = 0; int ssize = 1; while (ssize &lt; DEFAULT_CONCURRENCY_LEVEL) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; int segmentShift = 32 - sshift; int segmentMask = ssize - 1; @SuppressWarnings(\"unchecked\") Segment&lt;K,V&gt;[] segments = (Segment&lt;K,V&gt;[]) new Segment&lt;?,?&gt;[DEFAULT_CONCURRENCY_LEVEL]; for (int i = 0; i &lt; segments.length; ++i) segments[i] = new Segment&lt;K,V&gt;(LOAD_FACTOR); s.putFields().put(\"segments\", segments); s.putFields().put(\"segmentShift\", segmentShift); s.putFields().put(\"segmentMask\", segmentMask); s.writeFields(); Node&lt;K,V&gt;[] t; if ((t = table) != null) &#123; Traverser&lt;K,V&gt; it = new Traverser&lt;K,V&gt;(t, t.length, 0, t.length); for (Node&lt;K,V&gt; p; (p = it.advance()) != null; ) &#123; s.writeObject(p.key); s.writeObject(p.val); &#125; &#125; s.writeObject(null); s.writeObject(null); segments = null; // throw away &#125; 在多线程中，每一个Segment对象守护了一个HashEntry数组，当对ConcurrentHashMap中的元素修改时，在获取到对应的Segment数组角标后，都会对此Segment对象加锁，之后再去操作后面的HashEntry元素，这样每一个Segment对象下，都形成了一个小小的HashMap，在保证数据安全性的同时，又提高了同步的效率。只要不是操作同一个Segment对象的话，就不会出现线程等待的问题 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Collection","slug":"Collection","permalink":"https://zhouxu2016.github.io/tags/Collection/"}]},{"title":"CopyOnWriteArrayList的简单使用","slug":"CopyOnWriteArrayList","date":"2017-11-26T03:46:04.145Z","updated":"2017-11-26T04:56:58.603Z","comments":true,"path":"2017/11/26/CopyOnWriteArrayList/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/26/CopyOnWriteArrayList/","excerpt":"CopyOnWriteArrayList的介绍CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的, 一般在多线程操作时，一个线程对list进行修改。一个线程对list进行foreach时会出现, java.util.ConcurrentModificationException错误。 下面来看一个列子：两个线程,一个线程foreach,一个线程修改list的值。 读线程123456789101112131415161718/** * 读线程 */private static class ReadTask implements Runnable &#123; List&lt;String&gt; list; public ReadTask(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; for (String str : list) &#123; log.info(\"ReadTask&gt;&gt;&gt;&gt;&gt;\" + str); &#125; &#125;&#125;","text":"CopyOnWriteArrayList的介绍CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的, 一般在多线程操作时，一个线程对list进行修改。一个线程对list进行foreach时会出现, java.util.ConcurrentModificationException错误。 下面来看一个列子：两个线程,一个线程foreach,一个线程修改list的值。 读线程123456789101112131415161718/** * 读线程 */private static class ReadTask implements Runnable &#123; List&lt;String&gt; list; public ReadTask(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; for (String str : list) &#123; log.info(\"ReadTask&gt;&gt;&gt;&gt;&gt;\" + str); &#125; &#125;&#125; 写线程1234567891011121314151617181920/** * 写线程 */private static class WriteTask implements Runnable &#123; private int index; private List&lt;String&gt; list; public WriteTask(int index, List&lt;String&gt; list) &#123; this.index = index; this.list = list; &#125; @Override public void run() &#123; list.remove(index); list.add(index, \"write&gt;&gt;\" + index); &#125;&#125; 运行代码1234567891011121314151617181920212223242526272829 private void run() &#123; final int NUM = 10; List&lt;String&gt; list = new ArrayList&lt;String&gt;();// List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for (int i = 0; i &lt; NUM; i++) &#123; list.add(\"main_\" + i); &#125;// 创建指定线程数量的线程池 ExecutorService executorService = Executors.newFixedThreadPool(NUM); for (int i = 0; i &lt; NUM; i++) &#123; executorService.execute(new ReadTask(list)); executorService.execute(new WriteTask(i, list)); &#125;// 等待线程任务执行结束之后,关闭线程// executorService.shutdown();// 立即关闭所有线程(即便是正在执行线程任务的线程,但结果不一定能够成功关闭) executorService.shutdownNow(); &#125; public static void main(String[] args) &#123;// java.util.ConcurrentModificationException,修改并发异常 new CopyOnWriteArrayListDemo().run(); &#125; 运行结果 从结果中可以看出来。在多线程情况下报错。其原因就是多线程操作结果：那这个种方案不行我们就换个方案。用jdk自带的类CopyOnWriteArrayList来做容器。 换了种方案看代码 : 123 final int NUM = 10;// List&lt;String&gt; list = new ArrayList&lt;String&gt;(); List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); 运行上面的代码,没有报出,java.util.ConcurrentModificationException异常,说明了CopyOnWriteArrayList并发多线程的环境下,仍然能很好的工作 CopyOnWriteArrayList源码分析CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。 当有新元素加入的时候，如下图，创建新数组，并往新数组中加入一个新元素,这个时候，array这个引用仍然是指向原数组的。 当元素在新数组添加成功后，将array这个引用指向新数组。 CopyOnWriteArrayList的整个add操作都是在锁的保护下进行的,这样做是为了避免在多线程并发add的时候，复制出多个副本出来,把数据搞乱了，导致最终的数组数据不是我们期望的。 CopyOnWriteArrayList的add()方法操作的源代码如下: 12345678910111213141516171819public boolean add(E e) &#123; //1、先加锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; //2、拷贝数组 Object[] newElements = Arrays.copyOf(elements, len + 1); //3、将元素加入到新数组中 newElements[len] = e; //4、将array引用指向到新数组 setArray(newElements); return true; &#125; finally &#123; //5、解锁 lock.unlock(); &#125;&#125; 由于所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况: (1) 如果写操作未完成，那么直接读取原数组的数据；(2) 如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据；(3) 如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。 可见，CopyOnWriteArrayList的读操作是可以不用加锁的。 CopyOnWriteArrayList的使用场景通过上面的分析，CopyOnWriteArrayList 有几个缺点： (1) 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc(2) 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求； CopyOnWriteArrayList 合适读多写少的场景，不过这类慎用,因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。 CopyOnWriteArrayList总结如上面的分析CopyOnWriteArrayList表达的一些思想: (1) 读写分离，读和写分开(2) 最终一致性(3) 使用另外开辟空间的思路，来解决并发冲突 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Collection","slug":"Collection","permalink":"https://zhouxu2016.github.io/tags/Collection/"}]},{"title":"ExecutorService的理解与简单使用","slug":"ExecutorService","date":"2017-11-23T07:54:11.375Z","updated":"2017-11-26T05:00:04.521Z","comments":true,"path":"2017/11/23/ExecutorService/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/23/ExecutorService/","excerpt":"ExecutorService的简介接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的ExecutorService的实现就是一个线程池的实现ExecutorService的实现由于 ExecutorService 只是一个接口，你如果需要使用它，那麽就需要提供一个该接口的实现。ExecutorService 接口在 java.util.concurrent 包中有如下实现类： 这里我简单使用其中2个实现类 ThreadPoolExecutor ScheduledThreadPoolExecutor","text":"ExecutorService的简介接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的ExecutorService的实现就是一个线程池的实现ExecutorService的实现由于 ExecutorService 只是一个接口，你如果需要使用它，那麽就需要提供一个该接口的实现。ExecutorService 接口在 java.util.concurrent 包中有如下实现类： 这里我简单使用其中2个实现类 ThreadPoolExecutor ScheduledThreadPoolExecutor ExecutorService样例这里有一个简单的使用Java 实现的 ExectorService 样例: 首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService ，创建了一个可以容纳10个线程任务的线程池。其次，向 execute() 方法中传递一个异步的 Runnable 接口的实现，这样做会让 ExecutorService 中的某个线程执行这个Runnable 线程 1234567891011121314 @Test public void executeRunnable() &#123;// 创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 异步执行线程任务 executorService2.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;);// 等待所有的线程执行线程任务完毕后,关闭线程 executorService2.shutdown(); &#125; 任务的委托(Task Delegation)下方展示了一个线程的把任务委托异步执行的ExecutorService的示意图。 一旦线程把任务委托给 ExecutorService，该线程就会继续执行与运行任务无关的其它任务。 创建一个ExecutorService你可以根据自己的需要来创建一个 ExecutorService ，也可以使用 Executors 工厂方法来创建一个 ExecutorService 实例。这里有几个创建 ExecutorService 的例子: 123456789101112131415161718 private ExecutorService executorService1; private ExecutorService executorService2; private ScheduledExecutorService executorService3; private static Logger log = Logger.getLogger(ExecutorDemo.class); @BeforeEach private void studyExecutor() &#123;// 创建线程池的三种方式// 1.创建SingleThread,创建一个线程的线程池 executorService1 = Executors.newSingleThreadExecutor();// 2.创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 3.创建周期性线程池 executorService3 = Executors.newScheduledThreadPool(10); &#125; ExecutorService使用方法这里有几种不同的方式让你将任务委托给一个 ExecutorService： 12345execute(new Runnable() &#123;&#125;)submit(new Runnable() &#123;&#125;)submit(new Callable&lt;Object&gt;() &#123;&#125;)invokeAny(...)invokeAll(...) 接下来把每個方法都试试看 execute(Runnable)方法 execute(Runnable) 接收一个 java.lang.Runnable 对象作为参数，并且以异步的方式执行它。如下是一个使用 ExecutorService 执行 Runnable 的例子： 1234567891011121314@Test public void executeRunnable() &#123;// 创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 异步执行线程任务 executorService2.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;);// 等待所有的线程执行线程任务完毕后,关闭线程 executorService2.shutdown(); &#125; 使用这种方式没有办法获取执行 Runnable 之后的结果，如果你希望获取运行之后的返回值，就必须使用接收 Callable 参数的 execute() 方法，后者将会在下文中提到。 submit(Runnable)方法 submit(Runnable) 同样接收一个 Runnable 的实现作为参数，但是会返回一个 Future 对象。这個 Future 对象可以用于判断 Runnable 是否结束执行。如下是一个 ExecutorService 的 submit() 方法的例子： 12345678910111213141516171819 @Test public void submitRunnable() &#123; Future&lt;?&gt; future = executorService2.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;); try &#123;// 如果任务执行结束则返回null System.out.println(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;\" + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown(); &#125; submit(Callable)方法 submit(Callable) 和方法 submit(Runnable) 比较类似，但是区别则在于它们接收不同的参数类型。Callable 的实例与 Runnable 的实例很类似，但是 Callable 的 call() 方法可以返回一个结果。方法 Runnable.run() 则不能返回结果。 Callable 的返回值可以从方法 submit(Callable) 返回的 Future 对象中获取。如下是一个 ExecutorService Callable 的样例： 12345678910111213141516171819 @Test public void submitCallableRunnable() &#123; Future&lt;Object&gt; future = executorService2.submit(new Callable&lt;Object&gt;() &#123;// 使用Callable接口可以返回一个结果 @Override public Object call() throws Exception &#123; return \"Callable Result\"; &#125; &#125;); try &#123;// 获取Callable接口中call()方法的返回结果 System.out.println(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown(); &#125; 上述样例代码会输出如下结果： 12future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Callable ResultProcess finished with exit code 0 inVokeAny()方法 invokeAny() 接收一个包含 Callable 对象的集合作为参数。调用该方法不会返回 Future 对象，而是返回集合中某一个 Callable 对象的结果，而且无法保证调用之后返回的结果是哪一个 Callable，只知道它是这些 Callable 中一个执行结束的 Callable 对象。如果一个任务运行完毕或者抛出异常，方法会取消其它的 Callable 的执行。以下是一个样例： 123456789101112131415161718192021222324252627282930313233343536@Testpublic void inVokeAnyRunnable() &#123; List&lt;Callable&lt;String&gt;&gt; callableList = new ArrayList&lt;Callable&lt;String&gt;&gt;(); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task1\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task2\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task3\"; &#125; &#125;); try &#123; String result = executorService2.invokeAny(callableList); log.info(\"result&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown();&#125; 以上样例代码会打印出在给定的集合中的某一个 Callable 的返回结果。我尝试运行了几次，结果都在改变。有时候返回结果是”Task 1”，有时候是”Task 2”，等等。 invokeAll()方法 invokeAll() 会调用存在于参数集合中的所有 Callable 对象，并且返回一个包含 Future 对象的集合，你可以通过这个返回的集合来管理每个 Callable 的执行结果。需要注意的是，任务有可能因为异常而导致运行结束，所以它可能并不是真的成功运行了。但是我们没有办法通过 Future 对象来了解到这个差异。以下是一个代码样例： 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void inVokeAllRunnable() &#123; List&lt;Callable&lt;String&gt;&gt; callableList = new ArrayList&lt;Callable&lt;String&gt;&gt;(); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task1\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task2\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task3\"; &#125; &#125;); try &#123; List&lt;Future&lt;String&gt;&gt; futureList = executorService2.invokeAll(callableList); for (Future&lt;String&gt; future : futureList) &#123; log.info(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + future.get()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown();&#125; ExecuteService服务的关闭当使用 ExecutorService 完毕之后，我们应该关闭它，这样才能保证线程不会继续保持运行状态。举例来说，如果你的程序通过 main() 方法启动，并且主线程退出了你的程序，如果你还有一个活动的 ExecutorService 存在于你的程序中，那么程序将会继续保持运行状态。存在于 ExecutorService 中的活动线程会阻止Java虚拟机关闭。为了关闭在 ExecutorService 中的线程，你需要调用 shutdown() 方法。ExecutorService 并不会马上关闭，而是不再接收新的任务，一旦所有的线程结束执行当前任务，ExecutorServie 才会真的关闭。所有在调用 shutdown() 方法之前提交到 ExecutorService 的任务都会执行。如果你希望立即关闭 ExecutorService，你可以调用 shutdownNow() 方法。这个方法会尝试马上关闭所有正在执行的任务，并且跳过所有已经提交但是还没有运行的任务。但是对于正在执行的任务，是否能够成功关闭它是无法保证的，有可能他们真的被关闭掉了，也有可能它会一直执行到任务结束。这是一个最好的尝试。 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://zhouxu2016.github.io/tags/Thread/"}]},{"title":"Java创建线程的三种方式简介","slug":"ThreadCreate","date":"2017-11-22T09:53:28.107Z","updated":"2017-11-23T05:06:01.846Z","comments":true,"path":"2017/11/22/ThreadCreate/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/22/ThreadCreate/","excerpt":"Java中创建线程主要有三种方式: 1.继承Thread类创建线程类 2.通过Runnable接口创建线程类 3.通过Callable和Future创建线程 继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。","text":"Java中创建线程主要有三种方式: 1.继承Thread类创建线程类 2.通过Runnable接口创建线程类 3.通过Callable和Future创建线程 继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。 123456789// 第一种创建线程的方式 new Thread() &#123; @Override public void run() &#123; super.run(); System.out.println(\"创建线程1&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125;.start(); 上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字 通过Runnable接口创建线程类（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动该线程。 12345678// 第二种创建线程的方式 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"创建线程2&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125;).start(); 通过Callable和Future创建线程（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 12345678910111213141516171819202122// 第三种创建线程的方式 CallableThreadTest callableThreadTest = new CallableThreadTest(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(callableThreadTest); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + \" 的循环变量i的值\" + i); if (i == 20) &#123; new Thread(futureTask, \"有返回值的线程\").start(); System.out.println(\"i == 20,当前线程&gt;&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125; try &#123;// 100 System.out.println(\"子线程的返回值&gt;&gt;&gt;&gt;&gt;\" + futureTask.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; 创建线程的三种方式的对比1.采用实现Runnable、Callable接口的方式创见多线程时， 优势是：线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是：编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 2.使用继承Thread类的方式创建多线程时 优势是：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是：线程类已经继承了Thread类，所以不能再继承其他父类。 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://zhouxu2016.github.io/tags/Thread/"}]},{"title":"高性能JSON框架之FastJson的简单使用","slug":"FastJsonDemo","date":"2017-11-03T13:43:01.975Z","updated":"2017-11-10T10:02:20.637Z","comments":true,"path":"2017/11/03/FastJsonDemo/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/03/FastJsonDemo/","excerpt":"前言FastJson的介绍:JSON协议使用方便，越来越流行,JSON的处理器有很多,这里我介绍一下FastJson,FastJson是阿里的开源框架,被不少企业使用,是一个极其优秀的Json框架,Github地址: FastJson FastJson的特点:1.FastJson数度快,无论序列化和反序列化,都是当之无愧的fast2.功能强大(支持普通JDK类包括任意Java Bean Class、Collection、Map、Date或enum)3.零依赖(没有依赖其它任何类库) FastJson的简单说明:FastJson对于json格式字符串的解析主要用到了一下三个类：1.JSON：fastJson的解析器，用于JSON格式字符串与JSON对象及javaBean之间的转换2.JSONObject：fastJson提供的json对象3.JSONArray：fastJson提供json数组对象 还在迷茫和彷徨吗,快上车,老司机带你飞!","text":"前言FastJson的介绍:JSON协议使用方便，越来越流行,JSON的处理器有很多,这里我介绍一下FastJson,FastJson是阿里的开源框架,被不少企业使用,是一个极其优秀的Json框架,Github地址: FastJson FastJson的特点:1.FastJson数度快,无论序列化和反序列化,都是当之无愧的fast2.功能强大(支持普通JDK类包括任意Java Bean Class、Collection、Map、Date或enum)3.零依赖(没有依赖其它任何类库) FastJson的简单说明:FastJson对于json格式字符串的解析主要用到了一下三个类：1.JSON：fastJson的解析器，用于JSON格式字符串与JSON对象及javaBean之间的转换2.JSONObject：fastJson提供的json对象3.JSONArray：fastJson提供json数组对象 还在迷茫和彷徨吗,快上车,老司机带你飞! FastJson的用法首先定义三个json格式的字符串 12345678//json字符串-简单对象型private static final String JSON_OBJ_STR = \"&#123;\\\"studentName\\\":\\\"lily\\\",\\\"studentAge\\\":12&#125;\";//json字符串-数组类型private static final String JSON_ARRAY_STR = \"[&#123;\\\"studentName\\\":\\\"lily\\\",\\\"studentAge\\\":12&#125;,&#123;\\\"studentName\\\":\\\"lucy\\\",\\\"studentAge\\\":15&#125;]\";//复杂格式json字符串private static final String COMPLEX_JSON_STR = \"&#123;\\\"teacherName\\\":\\\"crystall\\\",\\\"teacherAge\\\":27,\\\"course\\\":&#123;\\\"courseName\\\":\\\"english\\\",\\\"code\\\":1270&#125;,\\\"students\\\":[&#123;\\\"studentName\\\":\\\"lily\\\",\\\"studentAge\\\":12&#125;,&#123;\\\"studentName\\\":\\\"lucy\\\",\\\"studentAge\\\":15&#125;]&#125;\"; JSON格式字符串与JSON对象之间的转换json字符串-简单对象型与JSONObject之间的转换123456789101112/** * json字符串-简单对象型到JSONObject的转换 */@Testpublic void testJSONStrToJSONObject() &#123; JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); System.out.println(\"studentName: \" + jsonObject.getString(\"studentName\") + \":\" + \" studentAge: \" + jsonObject.getInteger(\"studentAge\"));&#125; 12345678910111213141516/** * JSONObject到json字符串-简单对象型的转换 */@Testpublic void testJSONObjectToJSONStr() &#123; //已知JSONObject,目标要转换为json字符串 JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); // 第一种方式 String jsonString = JSONObject.toJSONString(jsonObject); // 第二种方式 //String jsonString = jsonObject.toJSONString(); System.out.println(jsonString);&#125; json字符串(数组类型)与JSONArray之间的转换1234567891011121314151617181920212223242526272829303132333435363738394041/** * json字符串-数组类型到JSONArray的转换 */@Testpublic void testJSONStrToJSONArray() &#123; JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //遍历方式1 int size = jsonArray.size(); for (int i = 0; i &lt; size; i++) &#123; JSONObject jsonObject = jsonArray.getJSONObject(i); System.out.println(\"studentName: \" + jsonObject.getString(\"studentName\") + \":\" + \" studentAge: \" + jsonObject.getInteger(\"studentAge\")); &#125; //遍历方式2 for (Object obj : jsonArray) &#123; JSONObject jsonObject = (JSONObject) obj; System.out.println(\"studentName: \" + jsonObject.getString(\"studentName\") + \":\" + \" studentAge: \" + jsonObject.getInteger(\"studentAge\")); &#125;&#125;/** * JSONArray到json字符串-数组类型的转换 */@Testpublic void testJSONArrayToJSONStr() &#123; //已知JSONArray,目标要转换为json字符串 JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //第一种方式 String jsonString = JSONArray.toJSONString(jsonArray);// 第二种方式 //String jsonString = jsonArray.toJSONString(jsonArray); System.out.println(jsonString);&#125; 复杂json格式字符串与JSONObject之间的转换1234567891011121314/** * 复杂json格式字符串到JSONObject的转换 */@Testpublic void testComplexJSONStrToJSONObject() &#123; JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); String teacherName = jsonObject.getString(\"teacherName\"); Integer teacherAge = jsonObject.getInteger(\"teacherAge\"); System.out.println(\"teacherName: \" + teacherName + \" teacherAge: \" + teacherAge); JSONObject jsonObjectcourse = jsonObject.getJSONObject(\"course\"); //获取JSONObject中的数据 123456789101112131415161718192021222324252627282930313233343536 String courseName = jsonObjectcourse.getString(\"courseName\"); Integer code = jsonObjectcourse.getInteger(\"code\"); System.out.println(\"courseName: \" + courseName + \" code: \" + code); JSONArray jsonArraystudents = jsonObject.getJSONArray(\"students\"); //遍历JSONArray for (Object object : jsonArraystudents) &#123; JSONObject jsonObjectone = (JSONObject) object; String studentName = jsonObjectone.getString(\"studentName\"); Integer studentAge = jsonObjectone.getInteger(\"studentAge\"); System.out.println(\"studentName: \" + studentName + \" studentAge: \" + studentAge); &#125;&#125;/** * 复杂JSONObject到json格式字符串的转换 */@Testpublic void testJSONObjectToComplexJSONStr() &#123; //复杂JSONObject,目标要转换为json字符串 JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); //第一种方式 //String jsonString = JSONObject.toJSONString(jsonObject); //第二种方式 String jsonString = jsonObject.toJSONString(); System.out.println(jsonString);&#125; JSON格式字符串与javaBean之间的转换json字符串-简单对象型与javaBean之间的转换12345678910111213141516171819202122232425262728293031323334/** * json字符串-简单对象到JavaBean之间的转换 */@Testpublic void testJSONStrToJavaBeanObj() &#123; //第一种方式 JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); String studentName = jsonObject.getString(\"studentName\"); Integer studentAge = jsonObject.getInteger(\"studentAge\"); //Student student = new Student(studentName, studentAge); //第二种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 //Student student = JSONObject.parseObject(JSON_OBJ_STR, new TypeReference&lt;Student&gt;() &#123;&#125;); //第三种方式,使用Gson的思想 Student student = JSONObject.parseObject(JSON_OBJ_STR, Student.class); System.out.println(student);&#125;/** * JavaBean到json字符串-简单对象的转换 */@Testpublic void testJavaBeanObjToJSONStr() &#123; Student student = new Student(\"lily\", 12); String jsonString = JSONObject.toJSONString(student); System.out.println(jsonString);&#125; json字符串-数组类型与javaBean之间的转换1234567891011121314151617181920212223/** * json字符串-数组类型到JavaBean_List的转换 */@Testpublic void testJSONStrToJavaBeanList() &#123; //第一种方式 JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //遍历JSONArray List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); Student student = null; for (Object object : jsonArray) &#123; JSONObject jsonObjectone = (JSONObject) object; String studentName = jsonObjectone.getString(\"studentName\"); Integer studentAge = jsonObjectone.getInteger(\"studentAge\"); student = new Student(studentName,studentAge); students.add(student); &#125; System.out.println(\"students: \" + students); 123456789 //第二种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 List&lt;Student&gt; studentList = JSONArray.parseObject(JSON_ARRAY_STR, new TypeReference&lt;ArrayList&lt;Student&gt;&gt;() &#123;&#125;); System.out.println(\"studentList: \" + studentList); //第三种方式,使用Gson的思想 List&lt;Student&gt; studentList1 = JSONArray.parseArray(JSON_ARRAY_STR, Student.class); System.out.println(\"studentList1: \" + studentList1);&#125; 1234567891011121314151617/** * JavaBean_List到json字符串-数组类型的转换 */@Testpublic void testJavaBeanListToJSONStr() &#123; Student student = new Student(\"lily\", 12); Student studenttwo = new Student(\"lucy\", 15); List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); students.add(student); students.add(studenttwo); String jsonString = JSONArray.toJSONString(students); System.out.println(jsonString);&#125; 复杂json格式字符串与与javaBean之间的转换12345678910111213141516171819202122232425262728/** * 复杂json格式字符串到JavaBean_obj的转换 */@Testpublic void testComplexJSONStrToJavaBean()&#123; //第一种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 Teacher teacher = JSONObject.parseObject(COMPLEX_JSON_STR, new TypeReference&lt;Teacher&gt;() &#123;&#125;); System.out.println(teacher); //第二种方式,使用Gson思想 Teacher teacher1 = JSONObject.parseObject(COMPLEX_JSON_STR, Teacher.class); System.out.println(teacher1);&#125;/** * 复杂JavaBean_obj到json格式字符串的转换 */@Testpublic void testJavaBeanToComplexJSONStr()&#123; //已知复杂JavaBean_obj Teacher teacher = JSONObject.parseObject(COMPLEX_JSON_STR, new TypeReference&lt;Teacher&gt;() &#123;&#125;); String jsonString = JSONObject.toJSONString(teacher); System.out.println(jsonString);&#125; javaBean与json对象间的之间的转换简单javaBean与json对象之间的转换123456789101112131415161718192021222324252627282930313233343536/** * 简单JavaBean_obj到json对象的转换 */@Testpublic void testJavaBeanToJSONObject()&#123; //已知简单JavaBean_obj Student student = new Student(\"lily\", 12); //方式一 String jsonString = JSONObject.toJSONString(student); JSONObject jsonObject = JSONObject.parseObject(jsonString); System.out.println(jsonObject); //方式二 JSONObject jsonObject1 = (JSONObject) JSONObject.toJSON(student); System.out.println(jsonObject1);&#125;/** * 简单json对象到JavaBean_obj的转换 */@Testpublic void testJSONObjectToJavaBean()&#123; //已知简单json对象 JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); //第一种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 Student student = JSONObject.parseObject(jsonObject.toJSONString(), new TypeReference&lt;Student&gt;() &#123;&#125;); System.out.println(student); //第二种方式,使用Gson的思想 Student student1 = JSONObject.parseObject(jsonObject.toJSONString(), Student.class); System.out.println(student1);&#125; JavaList与JsonArray之间的转换12345678910111213141516171819202122232425262728293031323334353637383940414243/** * JavaList到JsonArray的转换 */@Testpublic void testJavaListToJsonArray() &#123; //已知JavaList Student student = new Student(\"lily\", 12); Student studenttwo = new Student(\"lucy\", 15); List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); students.add(student); students.add(studenttwo); //方式一 String jsonString = JSONArray.toJSONString(students); JSONArray jsonArray = JSONArray.parseArray(jsonString); System.out.println(jsonArray); //方式二 JSONArray jsonArray1 = (JSONArray) JSONArray.toJSON(students); System.out.println(jsonArray1);&#125;/** * JsonArray到JavaList的转换 */@Testpublic void testJsonArrayToJavaList() &#123; //已知JsonArray JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //第一种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 ArrayList&lt;Student&gt; students = JSONArray.parseObject(jsonArray.toJSONString(), new TypeReference&lt;ArrayList&lt;Student&gt;&gt;() &#123;&#125;); System.out.println(students); //第二种方式,使用Gson的思想 List&lt;Student&gt; students1 = JSONArray.parseArray(jsonArray.toJSONString(), Student.class); System.out.println(students1);&#125; 复杂JavaBean_obj与json对象之间的转换123456789101112131415161718192021222324252627/** * 复杂JavaBean_obj到json对象的转换 */@Testpublic void testComplexJavaBeanToJSONObject() &#123; //已知复杂JavaBean_obj Student student = new Student(\"lily\", 12); Student studenttwo = new Student(\"lucy\", 15); List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); students.add(student); students.add(studenttwo); Course course = new Course(\"english\", 1270); Teacher teacher = new Teacher(\"crystall\", 27, course, students); //方式一 String jsonString = JSONObject.toJSONString(teacher); JSONObject jsonObject = JSONObject.parseObject(jsonString); System.out.println(jsonObject); //方式二 JSONObject jsonObject1 = (JSONObject) JSONObject.toJSON(teacher); System.out.println(jsonObject1);&#125; 123456789101112131415161718/** * 复杂json对象到JavaBean_obj的转换 */@Testpublic void testComplexJSONObjectToJavaBean() &#123; //已知复杂json对象 JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); //第一种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 Teacher teacher = JSONObject.parseObject(jsonObject.toJSONString(), new TypeReference&lt;Teacher&gt;() &#123;&#125;); System.out.println(teacher); //第二种方式,使用Gson的思想 Teacher teacher1 = JSONObject.parseObject(jsonObject.toJSONString(), Teacher.class); System.out.println(teacher1);&#125; 源码本篇博客的源码都在我的Github上,FastJsonDemo,欢迎大家Fork and Star! 总结好啦,FastJson的基本用法就介绍完了,送人玫瑰,手留余香,学习使我快乐,分享让大家快乐,欢迎大家点赞收藏噢! 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://zhouxu2016.github.io/tags/Json/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-03T06:57:13.240Z","updated":"2017-11-23T04:50:38.076Z","comments":true,"path":"2017/11/03/hello-world/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Study","slug":"Study","permalink":"https://zhouxu2016.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://zhouxu2016.github.io/tags/Study/"}]}]}