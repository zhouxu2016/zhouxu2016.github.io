{"meta":{"title":"ZhouXu'Blog","subtitle":null,"description":"NEVER GIVE UP;","author":"zhouxu","url":"https://zhouxu2016.github.io"},"pages":[{"title":"about","date":"2017-11-06T13:36:50.000Z","updated":"2017-11-09T12:31:53.904Z","comments":false,"path":"about/index.html","permalink":"https://zhouxu2016.github.io/about/index.html","excerpt":"","text":"Java开发工程师 互联网金融,微服务架构 © Copyright Hand China Co.Ltd"},{"title":"Categories","date":"2017-11-09T08:32:40.635Z","updated":"2017-11-09T08:32:40.635Z","comments":false,"path":"categories/index.html","permalink":"https://zhouxu2016.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-09T08:32:27.905Z","updated":"2017-11-09T08:32:27.905Z","comments":false,"path":"tags/index.html","permalink":"https://zhouxu2016.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ExecutorService的理解与简单使用","slug":"ExecutorService","date":"2017-11-23T07:54:11.375Z","updated":"2017-11-23T12:50:30.610Z","comments":true,"path":"2017/11/23/ExecutorService/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/23/ExecutorService/","excerpt":"### 前言 ###接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的ExecutorService的实现就是一个线程池的实现### ExecutorService样例 ###这里有一个简单的使用Java 实现的 ExectorService 样例:首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService ，创建了一个可以容纳10个线程任务的线程池。其次，向 execute() 方法中传递一个异步的 Runnable 接口的实现，这样做会让 ExecutorService 中的某个线程执行这个Runnable 线程","text":"### 前言 ###接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的ExecutorService的实现就是一个线程池的实现### ExecutorService样例 ###这里有一个简单的使用Java 实现的 ExectorService 样例:首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService ，创建了一个可以容纳10个线程任务的线程池。其次，向 execute() 方法中传递一个异步的 Runnable 接口的实现，这样做会让 ExecutorService 中的某个线程执行这个Runnable 线程### 任务的委托(Task Delegation) ###下方展示了一个线程的把任务委托异步执行的ExecutorService的示意图。 一旦线程把任务委托给 ExecutorService，该线程就会继续执行与运行任务无关的其它任务。 1234567891011121314 @Test public void executeRunnable() &#123;// 创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 异步执行线程任务 executorService2.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;);// 等待所有的线程执行线程任务完毕后,关闭线程 executorService2.shutdown(); &#125; ExecutorService的实现由于 ExecutorService 只是一个接口，你如果需要使用它，那麽就需要提供一个该接口的实现。ExecutorService 接口在 java.util.concurrent 包中有如下实现类： 这里我简单使用其中2个实现类: ThreadPoolExecutor ScheduledThreadPoolExecutor 创建一个ExecutorService你可以根据自己的需要来创建一个 ExecutorService ，也可以使用 Executors 工厂方法来创建一个 ExecutorService 实例。这里有几个创建 ExecutorService 的例子: 123456789101112131415161718 private ExecutorService executorService1; private ExecutorService executorService2; private ScheduledExecutorService executorService3; private static Logger log = Logger.getLogger(ExecutorDemo.class); @BeforeEach private void studyExecutor() &#123;// 创建线程池的三种方式// 1.创建SingleThread,创建一个线程的线程池 executorService1 = Executors.newSingleThreadExecutor();// 2.创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 3.创建周期性线程池 executorService3 = Executors.newScheduledThreadPool(10); &#125; ExecutorService使用方法这里有几种不同的方式让你将任务委托给一个 ExecutorService： 12345execute(new Runnable() &#123;&#125;)submit(new Runnable() &#123;&#125;)submit(new Callable&lt;Object&gt;() &#123;&#125;)invokeAny(...)invokeAll(...) 接下来把每個方法都试试看 execute(Runnable)方法 execute(Runnable) 接收一个 java.lang.Runnable 对象作为参数，并且以异步的方式执行它。如下是一个使用 ExecutorService 执行 Runnable 的例子： 1234567891011121314@Test public void executeRunnable() &#123;// 创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 异步执行线程任务 executorService2.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;);// 等待所有的线程执行线程任务完毕后,关闭线程 executorService2.shutdown(); &#125; 使用这种方式没有办法获取执行 Runnable 之后的结果，如果你希望获取运行之后的返回值，就必须使用接收 Callable 参数的 execute() 方法，后者将会在下文中提到。 submit(Runnable)方法 submit(Runnable) 同样接收一个 Runnable 的实现作为参数，但是会返回一个 Future 对象。这個 Future 对象可以用于判断 Runnable 是否结束执行。如下是一个 ExecutorService 的 submit() 方法的例子： 12345678910111213141516171819 @Test public void submitRunnable() &#123; Future&lt;?&gt; future = executorService2.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;); try &#123;// 如果任务执行结束则返回null System.out.println(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;\" + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown(); &#125; submit(Callable)方法 submit(Callable) 和方法 submit(Runnable) 比较类似，但是区别则在于它们接收不同的参数类型。Callable 的实例与 Runnable 的实例很类似，但是 Callable 的 call() 方法可以返回一个结果。方法 Runnable.run() 则不能返回结果。 Callable 的返回值可以从方法 submit(Callable) 返回的 Future 对象中获取。如下是一个 ExecutorService Callable 的样例： 12345678910111213141516171819 @Test public void submitCallableRunnable() &#123; Future&lt;Object&gt; future = executorService2.submit(new Callable&lt;Object&gt;() &#123;// 使用Callable接口可以返回一个结果 @Override public Object call() throws Exception &#123; return \"Callable Result\"; &#125; &#125;); try &#123;// 获取Callable接口中call()方法的返回结果 System.out.println(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown(); &#125; 上述样例代码会输出如下结果： 12future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Callable ResultProcess finished with exit code 0 inVokeAny()方法 invokeAny() 接收一个包含 Callable 对象的集合作为参数。调用该方法不会返回 Future 对象，而是返回集合中某一个 Callable 对象的结果，而且无法保证调用之后返回的结果是哪一个 Callable，只知道它是这些 Callable 中一个执行结束的 Callable 对象。如果一个任务运行完毕或者抛出异常，方法会取消其它的 Callable 的执行。以下是一个样例： 123456789101112131415161718192021222324252627282930313233343536@Testpublic void inVokeAnyRunnable() &#123; List&lt;Callable&lt;String&gt;&gt; callableList = new ArrayList&lt;Callable&lt;String&gt;&gt;(); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task1\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task2\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task3\"; &#125; &#125;); try &#123; String result = executorService2.invokeAny(callableList); log.info(\"result&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown();&#125; 以上样例代码会打印出在给定的集合中的某一个 Callable 的返回结果。我尝试运行了几次，结果都在改变。有时候返回结果是”Task 1”，有时候是”Task 2”，等等。 invokeAll()方法 invokeAll() 会调用存在于参数集合中的所有 Callable 对象，并且返回一个包含 Future 对象的集合，你可以通过这个返回的集合来管理每个 Callable 的执行结果。需要注意的是，任务有可能因为异常而导致运行结束，所以它可能并不是真的成功运行了。但是我们没有办法通过 Future 对象来了解到这个差异。以下是一个代码样例： 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void inVokeAllRunnable() &#123; List&lt;Callable&lt;String&gt;&gt; callableList = new ArrayList&lt;Callable&lt;String&gt;&gt;(); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task1\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task2\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task3\"; &#125; &#125;); try &#123; List&lt;Future&lt;String&gt;&gt; futureList = executorService2.invokeAll(callableList); for (Future&lt;String&gt; future : futureList) &#123; log.info(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + future.get()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown();&#125; ExecuteService服务的关闭当使用 ExecutorService 完毕之后，我们应该关闭它，这样才能保证线程不会继续保持运行状态。举例来说，如果你的程序通过 main() 方法启动，并且主线程退出了你的程序，如果你还有一个活动的 ExecutorService 存在于你的程序中，那么程序将会继续保持运行状态。存在于 ExecutorService 中的活动线程会阻止Java虚拟机关闭。为了关闭在 ExecutorService 中的线程，你需要调用 shutdown() 方法。ExecutorService 并不会马上关闭，而是不再接收新的任务，一旦所有的线程结束执行当前任务，ExecutorServie 才会真的关闭。所有在调用 shutdown() 方法之前提交到 ExecutorService 的任务都会执行。如果你希望立即关闭 ExecutorService，你可以调用 shutdownNow() 方法。这个方法会尝试马上关闭所有正在执行的任务，并且跳过所有已经提交但是还没有运行的任务。但是对于正在执行的任务，是否能够成功关闭它是无法保证的，有可能他们真的被关闭掉了，也有可能它会一直执行到任务结束。这是一个最好的尝试。 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://zhouxu2016.github.io/tags/Thread/"}]},{"title":"Java创建线程的三种方式简介","slug":"ThreadCreate","date":"2017-11-22T09:53:28.107Z","updated":"2017-11-23T05:06:01.846Z","comments":true,"path":"2017/11/22/ThreadCreate/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/22/ThreadCreate/","excerpt":"Java中创建线程主要有三种方式: 1.继承Thread类创建线程类 2.通过Runnable接口创建线程类 3.通过Callable和Future创建线程 继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。","text":"Java中创建线程主要有三种方式: 1.继承Thread类创建线程类 2.通过Runnable接口创建线程类 3.通过Callable和Future创建线程 继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。 123456789// 第一种创建线程的方式 new Thread() &#123; @Override public void run() &#123; super.run(); System.out.println(\"创建线程1&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125;.start(); 上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字 通过Runnable接口创建线程类（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动该线程。 12345678// 第二种创建线程的方式 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"创建线程2&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125;).start(); 通过Callable和Future创建线程（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 12345678910111213141516171819202122// 第三种创建线程的方式 CallableThreadTest callableThreadTest = new CallableThreadTest(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(callableThreadTest); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + \" 的循环变量i的值\" + i); if (i == 20) &#123; new Thread(futureTask, \"有返回值的线程\").start(); System.out.println(\"i == 20,当前线程&gt;&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125; try &#123;// 100 System.out.println(\"子线程的返回值&gt;&gt;&gt;&gt;&gt;\" + futureTask.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; 创建线程的三种方式的对比1.采用实现Runnable、Callable接口的方式创见多线程时， 优势是：线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是：编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 2.使用继承Thread类的方式创建多线程时 优势是：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是：线程类已经继承了Thread类，所以不能再继承其他父类。 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://zhouxu2016.github.io/tags/Thread/"}]},{"title":"高性能JSON框架之FastJson的简单使用","slug":"FastJsonDemo","date":"2017-11-03T13:43:01.975Z","updated":"2017-11-10T10:02:20.637Z","comments":true,"path":"2017/11/03/FastJsonDemo/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/03/FastJsonDemo/","excerpt":"前言FastJson的介绍:JSON协议使用方便，越来越流行,JSON的处理器有很多,这里我介绍一下FastJson,FastJson是阿里的开源框架,被不少企业使用,是一个极其优秀的Json框架,Github地址: FastJson FastJson的特点:1.FastJson数度快,无论序列化和反序列化,都是当之无愧的fast2.功能强大(支持普通JDK类包括任意Java Bean Class、Collection、Map、Date或enum)3.零依赖(没有依赖其它任何类库) FastJson的简单说明:FastJson对于json格式字符串的解析主要用到了一下三个类：1.JSON：fastJson的解析器，用于JSON格式字符串与JSON对象及javaBean之间的转换2.JSONObject：fastJson提供的json对象3.JSONArray：fastJson提供json数组对象 还在迷茫和彷徨吗,快上车,老司机带你飞!","text":"前言FastJson的介绍:JSON协议使用方便，越来越流行,JSON的处理器有很多,这里我介绍一下FastJson,FastJson是阿里的开源框架,被不少企业使用,是一个极其优秀的Json框架,Github地址: FastJson FastJson的特点:1.FastJson数度快,无论序列化和反序列化,都是当之无愧的fast2.功能强大(支持普通JDK类包括任意Java Bean Class、Collection、Map、Date或enum)3.零依赖(没有依赖其它任何类库) FastJson的简单说明:FastJson对于json格式字符串的解析主要用到了一下三个类：1.JSON：fastJson的解析器，用于JSON格式字符串与JSON对象及javaBean之间的转换2.JSONObject：fastJson提供的json对象3.JSONArray：fastJson提供json数组对象 还在迷茫和彷徨吗,快上车,老司机带你飞! FastJson的用法首先定义三个json格式的字符串 12345678//json字符串-简单对象型private static final String JSON_OBJ_STR = \"&#123;\\\"studentName\\\":\\\"lily\\\",\\\"studentAge\\\":12&#125;\";//json字符串-数组类型private static final String JSON_ARRAY_STR = \"[&#123;\\\"studentName\\\":\\\"lily\\\",\\\"studentAge\\\":12&#125;,&#123;\\\"studentName\\\":\\\"lucy\\\",\\\"studentAge\\\":15&#125;]\";//复杂格式json字符串private static final String COMPLEX_JSON_STR = \"&#123;\\\"teacherName\\\":\\\"crystall\\\",\\\"teacherAge\\\":27,\\\"course\\\":&#123;\\\"courseName\\\":\\\"english\\\",\\\"code\\\":1270&#125;,\\\"students\\\":[&#123;\\\"studentName\\\":\\\"lily\\\",\\\"studentAge\\\":12&#125;,&#123;\\\"studentName\\\":\\\"lucy\\\",\\\"studentAge\\\":15&#125;]&#125;\"; JSON格式字符串与JSON对象之间的转换json字符串-简单对象型与JSONObject之间的转换123456789101112/** * json字符串-简单对象型到JSONObject的转换 */@Testpublic void testJSONStrToJSONObject() &#123; JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); System.out.println(\"studentName: \" + jsonObject.getString(\"studentName\") + \":\" + \" studentAge: \" + jsonObject.getInteger(\"studentAge\"));&#125; 12345678910111213141516/** * JSONObject到json字符串-简单对象型的转换 */@Testpublic void testJSONObjectToJSONStr() &#123; //已知JSONObject,目标要转换为json字符串 JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); // 第一种方式 String jsonString = JSONObject.toJSONString(jsonObject); // 第二种方式 //String jsonString = jsonObject.toJSONString(); System.out.println(jsonString);&#125; json字符串(数组类型)与JSONArray之间的转换1234567891011121314151617181920212223242526272829303132333435363738394041/** * json字符串-数组类型到JSONArray的转换 */@Testpublic void testJSONStrToJSONArray() &#123; JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //遍历方式1 int size = jsonArray.size(); for (int i = 0; i &lt; size; i++) &#123; JSONObject jsonObject = jsonArray.getJSONObject(i); System.out.println(\"studentName: \" + jsonObject.getString(\"studentName\") + \":\" + \" studentAge: \" + jsonObject.getInteger(\"studentAge\")); &#125; //遍历方式2 for (Object obj : jsonArray) &#123; JSONObject jsonObject = (JSONObject) obj; System.out.println(\"studentName: \" + jsonObject.getString(\"studentName\") + \":\" + \" studentAge: \" + jsonObject.getInteger(\"studentAge\")); &#125;&#125;/** * JSONArray到json字符串-数组类型的转换 */@Testpublic void testJSONArrayToJSONStr() &#123; //已知JSONArray,目标要转换为json字符串 JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //第一种方式 String jsonString = JSONArray.toJSONString(jsonArray);// 第二种方式 //String jsonString = jsonArray.toJSONString(jsonArray); System.out.println(jsonString);&#125; 复杂json格式字符串与JSONObject之间的转换1234567891011121314/** * 复杂json格式字符串到JSONObject的转换 */@Testpublic void testComplexJSONStrToJSONObject() &#123; JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); String teacherName = jsonObject.getString(\"teacherName\"); Integer teacherAge = jsonObject.getInteger(\"teacherAge\"); System.out.println(\"teacherName: \" + teacherName + \" teacherAge: \" + teacherAge); JSONObject jsonObjectcourse = jsonObject.getJSONObject(\"course\"); //获取JSONObject中的数据 123456789101112131415161718192021222324252627282930313233343536 String courseName = jsonObjectcourse.getString(\"courseName\"); Integer code = jsonObjectcourse.getInteger(\"code\"); System.out.println(\"courseName: \" + courseName + \" code: \" + code); JSONArray jsonArraystudents = jsonObject.getJSONArray(\"students\"); //遍历JSONArray for (Object object : jsonArraystudents) &#123; JSONObject jsonObjectone = (JSONObject) object; String studentName = jsonObjectone.getString(\"studentName\"); Integer studentAge = jsonObjectone.getInteger(\"studentAge\"); System.out.println(\"studentName: \" + studentName + \" studentAge: \" + studentAge); &#125;&#125;/** * 复杂JSONObject到json格式字符串的转换 */@Testpublic void testJSONObjectToComplexJSONStr() &#123; //复杂JSONObject,目标要转换为json字符串 JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); //第一种方式 //String jsonString = JSONObject.toJSONString(jsonObject); //第二种方式 String jsonString = jsonObject.toJSONString(); System.out.println(jsonString);&#125; JSON格式字符串与javaBean之间的转换json字符串-简单对象型与javaBean之间的转换12345678910111213141516171819202122232425262728293031323334/** * json字符串-简单对象到JavaBean之间的转换 */@Testpublic void testJSONStrToJavaBeanObj() &#123; //第一种方式 JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); String studentName = jsonObject.getString(\"studentName\"); Integer studentAge = jsonObject.getInteger(\"studentAge\"); //Student student = new Student(studentName, studentAge); //第二种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 //Student student = JSONObject.parseObject(JSON_OBJ_STR, new TypeReference&lt;Student&gt;() &#123;&#125;); //第三种方式,使用Gson的思想 Student student = JSONObject.parseObject(JSON_OBJ_STR, Student.class); System.out.println(student);&#125;/** * JavaBean到json字符串-简单对象的转换 */@Testpublic void testJavaBeanObjToJSONStr() &#123; Student student = new Student(\"lily\", 12); String jsonString = JSONObject.toJSONString(student); System.out.println(jsonString);&#125; json字符串-数组类型与javaBean之间的转换1234567891011121314151617181920212223/** * json字符串-数组类型到JavaBean_List的转换 */@Testpublic void testJSONStrToJavaBeanList() &#123; //第一种方式 JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //遍历JSONArray List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); Student student = null; for (Object object : jsonArray) &#123; JSONObject jsonObjectone = (JSONObject) object; String studentName = jsonObjectone.getString(\"studentName\"); Integer studentAge = jsonObjectone.getInteger(\"studentAge\"); student = new Student(studentName,studentAge); students.add(student); &#125; System.out.println(\"students: \" + students); 123456789 //第二种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 List&lt;Student&gt; studentList = JSONArray.parseObject(JSON_ARRAY_STR, new TypeReference&lt;ArrayList&lt;Student&gt;&gt;() &#123;&#125;); System.out.println(\"studentList: \" + studentList); //第三种方式,使用Gson的思想 List&lt;Student&gt; studentList1 = JSONArray.parseArray(JSON_ARRAY_STR, Student.class); System.out.println(\"studentList1: \" + studentList1);&#125; 1234567891011121314151617/** * JavaBean_List到json字符串-数组类型的转换 */@Testpublic void testJavaBeanListToJSONStr() &#123; Student student = new Student(\"lily\", 12); Student studenttwo = new Student(\"lucy\", 15); List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); students.add(student); students.add(studenttwo); String jsonString = JSONArray.toJSONString(students); System.out.println(jsonString);&#125; 复杂json格式字符串与与javaBean之间的转换12345678910111213141516171819202122232425262728/** * 复杂json格式字符串到JavaBean_obj的转换 */@Testpublic void testComplexJSONStrToJavaBean()&#123; //第一种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 Teacher teacher = JSONObject.parseObject(COMPLEX_JSON_STR, new TypeReference&lt;Teacher&gt;() &#123;&#125;); System.out.println(teacher); //第二种方式,使用Gson思想 Teacher teacher1 = JSONObject.parseObject(COMPLEX_JSON_STR, Teacher.class); System.out.println(teacher1);&#125;/** * 复杂JavaBean_obj到json格式字符串的转换 */@Testpublic void testJavaBeanToComplexJSONStr()&#123; //已知复杂JavaBean_obj Teacher teacher = JSONObject.parseObject(COMPLEX_JSON_STR, new TypeReference&lt;Teacher&gt;() &#123;&#125;); String jsonString = JSONObject.toJSONString(teacher); System.out.println(jsonString);&#125; javaBean与json对象间的之间的转换简单javaBean与json对象之间的转换123456789101112131415161718192021222324252627282930313233343536/** * 简单JavaBean_obj到json对象的转换 */@Testpublic void testJavaBeanToJSONObject()&#123; //已知简单JavaBean_obj Student student = new Student(\"lily\", 12); //方式一 String jsonString = JSONObject.toJSONString(student); JSONObject jsonObject = JSONObject.parseObject(jsonString); System.out.println(jsonObject); //方式二 JSONObject jsonObject1 = (JSONObject) JSONObject.toJSON(student); System.out.println(jsonObject1);&#125;/** * 简单json对象到JavaBean_obj的转换 */@Testpublic void testJSONObjectToJavaBean()&#123; //已知简单json对象 JSONObject jsonObject = JSONObject.parseObject(JSON_OBJ_STR); //第一种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 Student student = JSONObject.parseObject(jsonObject.toJSONString(), new TypeReference&lt;Student&gt;() &#123;&#125;); System.out.println(student); //第二种方式,使用Gson的思想 Student student1 = JSONObject.parseObject(jsonObject.toJSONString(), Student.class); System.out.println(student1);&#125; JavaList与JsonArray之间的转换12345678910111213141516171819202122232425262728293031323334353637383940414243/** * JavaList到JsonArray的转换 */@Testpublic void testJavaListToJsonArray() &#123; //已知JavaList Student student = new Student(\"lily\", 12); Student studenttwo = new Student(\"lucy\", 15); List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); students.add(student); students.add(studenttwo); //方式一 String jsonString = JSONArray.toJSONString(students); JSONArray jsonArray = JSONArray.parseArray(jsonString); System.out.println(jsonArray); //方式二 JSONArray jsonArray1 = (JSONArray) JSONArray.toJSON(students); System.out.println(jsonArray1);&#125;/** * JsonArray到JavaList的转换 */@Testpublic void testJsonArrayToJavaList() &#123; //已知JsonArray JSONArray jsonArray = JSONArray.parseArray(JSON_ARRAY_STR); //第一种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 ArrayList&lt;Student&gt; students = JSONArray.parseObject(jsonArray.toJSONString(), new TypeReference&lt;ArrayList&lt;Student&gt;&gt;() &#123;&#125;); System.out.println(students); //第二种方式,使用Gson的思想 List&lt;Student&gt; students1 = JSONArray.parseArray(jsonArray.toJSONString(), Student.class); System.out.println(students1);&#125; 复杂JavaBean_obj与json对象之间的转换123456789101112131415161718192021222324252627/** * 复杂JavaBean_obj到json对象的转换 */@Testpublic void testComplexJavaBeanToJSONObject() &#123; //已知复杂JavaBean_obj Student student = new Student(\"lily\", 12); Student studenttwo = new Student(\"lucy\", 15); List&lt;Student&gt; students = new ArrayList&lt;Student&gt;(); students.add(student); students.add(studenttwo); Course course = new Course(\"english\", 1270); Teacher teacher = new Teacher(\"crystall\", 27, course, students); //方式一 String jsonString = JSONObject.toJSONString(teacher); JSONObject jsonObject = JSONObject.parseObject(jsonString); System.out.println(jsonObject); //方式二 JSONObject jsonObject1 = (JSONObject) JSONObject.toJSON(teacher); System.out.println(jsonObject1);&#125; 123456789101112131415161718/** * 复杂json对象到JavaBean_obj的转换 */@Testpublic void testComplexJSONObjectToJavaBean() &#123; //已知复杂json对象 JSONObject jsonObject = JSONObject.parseObject(COMPLEX_JSON_STR); //第一种方式,使用TypeReference&lt;T&gt;类,由于其构造方法使用protected进行修饰,故创建其子类 Teacher teacher = JSONObject.parseObject(jsonObject.toJSONString(), new TypeReference&lt;Teacher&gt;() &#123;&#125;); System.out.println(teacher); //第二种方式,使用Gson的思想 Teacher teacher1 = JSONObject.parseObject(jsonObject.toJSONString(), Teacher.class); System.out.println(teacher1);&#125; 源码本篇博客的源码都在我的Github上,FastJsonDemo,欢迎大家Fork and Star! 总结好啦,FastJson的基本用法就介绍完了,送人玫瑰,手留余香,学习使我快乐,分享让大家快乐,欢迎大家点赞收藏噢! 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Json","slug":"Json","permalink":"https://zhouxu2016.github.io/tags/Json/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-03T06:57:13.240Z","updated":"2017-11-23T04:50:38.076Z","comments":true,"path":"2017/11/03/hello-world/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Study","slug":"Study","permalink":"https://zhouxu2016.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://zhouxu2016.github.io/tags/Study/"}]}]}