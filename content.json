{"meta":{"title":"ZhouXu'Blog","subtitle":null,"description":"NEVER GIVE UP;","author":"zhouxu","url":"https://zhouxu2016.github.io"},"pages":[{"title":"Categories","date":"2017-11-09T08:32:40.635Z","updated":"2017-11-09T08:32:40.635Z","comments":false,"path":"categories/index.html","permalink":"https://zhouxu2016.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-11-06T13:36:50.000Z","updated":"2017-11-09T12:31:53.904Z","comments":false,"path":"about/index.html","permalink":"https://zhouxu2016.github.io/about/index.html","excerpt":"","text":"Java开发工程师 互联网金融,微服务架构 © Copyright Hand China Co.Ltd"},{"title":"Tags","date":"2017-11-09T08:32:27.905Z","updated":"2017-11-09T08:32:27.905Z","comments":false,"path":"tags/index.html","permalink":"https://zhouxu2016.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HttpClient与Spring Boot之间的json数据交互","slug":"HttpClient","date":"2017-12-15T08:54:52.304Z","updated":"2019-05-23T02:34:40.002Z","comments":true,"path":"2017/12/15/HttpClient/","link":"","permalink":"https://zhouxu2016.github.io/2017/12/15/HttpClient/","excerpt":"使用HttpClient传递key/value数据HttpClient网络请求代码HttpClient发送key/value数据,返回json格式数据 12345678910111213141516171819202122232425262728293031323334@Testpublic void test() &#123; //网络请求地址 String url = \"http://localhost:8080/api/user\"; //请求方式为post请求 HttpPost httppost = new HttpPost(url); //创建网络请求对象 HttpClient httpClient = new DefaultHttpClient(); //请求体是Key/value数据格式,将key/value数据保存在NameValuePair中 List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(); params.add(new BasicNameValuePair(\"name\", \"changyuan\")); params.add(new BasicNameValuePair(\"age\", \"18\")); try &#123; //使用UrlEncodedFormEntity设置请求体的编码格式为UTF_8(如果不设置编码格式,后台获取的数据可能会出现中文乱码) UrlEncodedFormEntity urlEntity = new UrlEncodedFormEntity(params, HTTP.UTF_8); //设置数据 httppost.setEntity(urlEntity); //使用HttpClient发送网络请求 HttpResponse response = httpClient.execute(httppost); //如果状态码为200,就是正常返回 if (response.getStatusLine().getStatusCode() == 200) &#123; //获取请求的数据(response.getEntity()方法可以获取请求的数据) String result = EntityUtils.toString(response.getEntity()); log.info(\"result&gt;&gt;&gt;&gt;&gt; \" + result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","text":"使用HttpClient传递key/value数据HttpClient网络请求代码HttpClient发送key/value数据,返回json格式数据 12345678910111213141516171819202122232425262728293031323334@Testpublic void test() &#123; //网络请求地址 String url = \"http://localhost:8080/api/user\"; //请求方式为post请求 HttpPost httppost = new HttpPost(url); //创建网络请求对象 HttpClient httpClient = new DefaultHttpClient(); //请求体是Key/value数据格式,将key/value数据保存在NameValuePair中 List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(); params.add(new BasicNameValuePair(\"name\", \"changyuan\")); params.add(new BasicNameValuePair(\"age\", \"18\")); try &#123; //使用UrlEncodedFormEntity设置请求体的编码格式为UTF_8(如果不设置编码格式,后台获取的数据可能会出现中文乱码) UrlEncodedFormEntity urlEntity = new UrlEncodedFormEntity(params, HTTP.UTF_8); //设置数据 httppost.setEntity(urlEntity); //使用HttpClient发送网络请求 HttpResponse response = httpClient.execute(httppost); //如果状态码为200,就是正常返回 if (response.getStatusLine().getStatusCode() == 200) &#123; //获取请求的数据(response.getEntity()方法可以获取请求的数据) String result = EntityUtils.toString(response.getEntity()); log.info(\"result&gt;&gt;&gt;&gt;&gt; \" + result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 后台代码123456789101112131415161718192021/** * 用户控制层 */@RestControllerpublic class UserRestController &#123; private static Logger log = Logger.getLogger(UserRestController.class); //@RequestParam(value = \"userName\", required = true) @Autowired private UserService userService; @PostMapping(value = \"/api/user\") public User findUserByName(@RequestParam(value = \"name\") String name, @RequestParam(value = \"age\") Integer age) &#123; //System.out.println(\"name&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + name + \" age&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + age); log.info(\"name&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + name + \" age&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + age); return userService.findByName(name); &#125; &#125; 代码说明@RestController注解是用来作用所有的Controller层返回json数据,这个注解是Spring4+才有的,我这里使用Spring Boot 1.5.1.RELEASE版本,已经包含了Spring 4.3.6版本 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;&lt;/parent&gt; 运行结果12345678D:\\java\\jdk\\bin\\java...17:36:12.329 [main] DEBUG org.apache.http.impl.conn.BasicClientConnectionManager - Get connection for route &#123;&#125;-&gt;http://localhost:808017:36:12.379 [main] DEBUG org.apache.http.impl.conn.DefaultClientConnectionOperator - Connecting to localhost:808017:36:12.479 [main] DEBUG org.apache.http.impl.conn.BasicClientConnectionManager - Connection can be kept alive indefinitely17:36:12.479 [main] INFO org.spring.springboot.HttpClientTest - result&gt;&gt;&gt;&gt;&gt; &#123;\"id\":1,\"userName\":\"常远\",\"description\":\"北京工作\",\"city\":&#123;\"id\":1,\"provinceId\":1,\"cityName\":\"北京\",\"description\":\"北京工作\"&#125;,\"work\":&#123;\"id\":1,\"workAddress\":\"北京\",\"company\":\"北京\",\"name\":\"常远\"&#125;&#125;Process finished with exit code 0 使用HttpClient传递json数据HttpClient网络请求代码HttpClient发送json数据,返回json格式数据 1234567891011121314151617181920212223242526272829303132333435@Testpublic void testJson() &#123; //网络请求地址 String url = \"http://localhost:8080/api/user\"; //请求方式为post请求 HttpPost httppost = new HttpPost(url); //创建网络请求对象 HttpClient httpClient = new DefaultHttpClient(); try &#123; //请求体是json数据格式 String json = \"&#123;\\\"id\\\": \\\"1\\\",\\\"workAddress\\\": \\\"北京\\\",\\\"company\\\": \\\"北京\\\",\\\"name\\\": \\\"常远\\\"&#125;\"; //使用StringEntity设置请求体的编码格式为UTF_8(如果不设置编码格式,后台获取的数据可能会出现中文乱码) StringEntity stringEntity = new StringEntity(json,\"UTF-8\"); //发送json数据必须设置contentType stringEntity.setContentType(\"application/json\"); //设置数据 httppost.setEntity(stringEntity); //使用HttpClient发送网络请求 HttpResponse response = httpClient.execute(httppost); //如果状态码为200,就是正常返回 if (response.getStatusLine().getStatusCode() == 200) &#123; //返回json格式字符串 String result = EntityUtils.toString(response.getEntity()); log.info(\"result&gt;&gt;&gt;&gt;&gt; \" + result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 后台代码12345678//consumes的作用是指定请求数据的格式类型,可以同时指定数据格式类型以及字符编码//produces的作用是指定返回值类型,不但可以设置返回值类型还可以设定返回值的字符编@PostMapping(value = \"/api/user\", consumes = \"application/json;charset=utf-8\", produces = \"application/json;charset=utf-8\")public User findUserByName(@RequestBody Work work) &#123; log.info(\"work&gt;&gt;&gt;&gt;&gt; \" + work); return userService.findByName(\"\");&#125; 代码说明@PostMapping注解中的属性含义 1.consumes的作用是指定请求数据的格式类型,可以同时指定数据格式类型以及字符编码2.produces的作用是指定返回值类型,不但可以设置返回值类型还可以设定返回值的字符编 consumes和produces属性只是增加对请求数据格式和响应数据格式的校验 运行结果12345678910D:\\java\\jdk\\bin\\java...17:39:52.636 [main] DEBUG org.apache.http.headers - &gt;&gt; Content-Length: 7217:39:52.636 [main] DEBUG org.apache.http.headers - &gt;&gt; Content-Type: application/json17:39:52.636 [main] DEBUG org.apache.http.headers - &gt;&gt; Host: localhost:808017:39:52.636 [main] DEBUG org.apache.http.headers - &gt;&gt; Connection: Keep-Alive17:39:53.836 [main] DEBUG org.apache.http.impl.conn.BasicClientConnectionManager - Connection can be kept alive indefinitely17:39:53.836 [main] INFO org.spring.springboot.HttpClientTest - result&gt;&gt;&gt;&gt;&gt; &#123;\"id\":1,\"userName\":\"常远\",\"description\":\"北京工作\",\"city\":&#123;\"id\":1,\"provinceId\":1,\"cityName\":\"北京\",\"description\":\"北京工作\"&#125;,\"work\":&#123;\"id\":1,\"workAddress\":\"北京\",\"company\":\"北京\",\"name\":\"常远\"&#125;&#125;Process finished with exit code 0 博客中若有错误,欢迎大家指出噢,大家共同学习,共同提高,嘿嘿 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://zhouxu2016.github.io/categories/Spring-Boot/"}],"tags":[{"name":"HttpClient","slug":"HttpClient","permalink":"https://zhouxu2016.github.io/tags/HttpClient/"}]},{"title":"Spring MVC+ajax 实现json格式数据传递","slug":"Spring MVC ajax","date":"2017-12-15T07:07:28.479Z","updated":"2019-05-23T02:35:16.155Z","comments":true,"path":"2017/12/15/Spring MVC ajax/","link":"","permalink":"https://zhouxu2016.github.io/2017/12/15/Spring MVC ajax/","excerpt":"使用ajax传递JSON对象下面示例为ajax发送json对象,返回json格式数据123456789101112131415161718192021$.ajax(&#123; url: \"api/user\", type: \"POST\", timeout: txnTimeOut, async: true, dataType: \"json\", data: &#123;username : \"lucy\"&#125;, //注意：这里不能加下面这行，否则数据会传不到后台 //contentType:'application/json;charset=UTF-8', success: function(e)&#123; if($.txnIsSuzccess(e.respCode))&#123; //window.location.href=e.codeUrl; console.log(e); &#125;else&#123; exceptionHandle(e); &#125; &#125;, error: function(e)&#123; errorHandle(e); &#125;&#125;); 注意：这里不能加下面这行，否则数据会传不到后台 1contentType:'application/json;charset=UTF-8', 后台代码","text":"使用ajax传递JSON对象下面示例为ajax发送json对象,返回json格式数据123456789101112131415161718192021$.ajax(&#123; url: \"api/user\", type: \"POST\", timeout: txnTimeOut, async: true, dataType: \"json\", data: &#123;username : \"lucy\"&#125;, //注意：这里不能加下面这行，否则数据会传不到后台 //contentType:'application/json;charset=UTF-8', success: function(e)&#123; if($.txnIsSuzccess(e.respCode))&#123; //window.location.href=e.codeUrl; console.log(e); &#125;else&#123; exceptionHandle(e); &#125; &#125;, error: function(e)&#123; errorHandle(e); &#125;&#125;); 注意：这里不能加下面这行，否则数据会传不到后台 1contentType:'application/json;charset=UTF-8', 后台代码 1234567@ResponseBody@PostMapping(value = \"/api/user\", produces = \"application/json;charset=utf-8\")public Student selectRoles(String username) &#123; /* 逻辑代码 */ return null;&#125; 12//produces属性表示返回数据类型为jsonproduces = \"application/json;charset=utf-8\" 使用ajax传JSON字符串,使用@RequestBody接收传递json格式字符串,返回json数据12345678910111213141516171819$.ajax(&#123; url: \"find\", type: \"POST\", timeout: txnTimeOut, async: true, contentType: 'application/json;charset=UTF-8',//关键是要加上这行 dataType: \"json\", data: '&#123;\"name\":\"手机\",\"price\":999&#125;', success: function(e)&#123; if($.txnIsSuzccess(e.respCode))&#123; console.log(e); &#125;else&#123; exceptionHandle(e); &#125; &#125;, error: function(e)&#123; errorHandle(e); &#125;&#125;); 后台代码123456789//consumes的作用是指定请求数据的格式类型,可以同时指定数据格式类型以及字符编码//produces的作用是指定返回值类型,不但可以设置返回值类型还可以设定返回值的字符编码@ResponseBody@PostMapping(value = \"/find\", consumes = \"application/json;charset=utf-8\", produces = \"application/json;charset=utf-8\")public User findUserByName(@RequestBody User user) &#123; log.info(\"user&gt;&gt;&gt;&gt;&gt; \" + user); return userService.findByName(\"\");&#125; ajax代码说明123456//contentType指定传递的数据为json字符串(如果不指定为application/json;charset=UTF-8,//后台无法进行参数绑定)contentType: 'application/json;charset=UTF-8',//关键是要加上这行 //dataType指定返回的数据为json数据格式dataType: \"json\", java代码说明1234567//consumes的作用是指定请求数据的格式类型,可以同时指定数据格式类型以及字符编码//produces的作用是指定返回值类型,不但可以设置返回值类型还可以设定返回值的字符编码@PostMapping(value = \"/find\", consumes = \"application/json;charset=utf-8\", produces = \"application/json;charset=utf-8\")//@RequestBody注解用来接受json数据,进行参数绑定(如果不在参数前使用此注解,无法进行参数绑定)//@ResponseBody注解用来生成json数据public User findUserByName(@RequestBody User user) 注意: ajax代码中必须指定contentType为json数据格式,同时java代码中必须在参数前使用@RequestBody注解, 否则无法进行参数绑定,后台无法获取前台传递的数据 User类12345678910111213141516171819202122232425262728293031323334353637383940/** * Created by zhouxu on 2017/12/15 15:58. */public class User &#123; private String name; private double price; public User() &#123; &#125; public User(String name, double price) &#123; this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", price=\" + price + '&#125;'; &#125;&#125; 使用ajax请求key/value，输出是jsonajax代码12345678910111213141516//请求key/value，输出是jsonfunction responseJson()&#123; $.ajax(&#123; type:'post', url:'api/user', //请求是key/value这里不需要指定contentType，因为默认就 是key/value类型 //contentType:'application/json;charset=utf-8', //数据格式是json串，商品信息 data:'name=手机&amp;price=999', success:function(data)&#123;//返回json结果 alert(data.name); &#125; &#125;);&#125; java代码12345678@ResponseBody@PostMapping(value = \"/api/user\")public User findUserByName(@RequestParam(value = \"name\") String name, @RequestParam(value = \"price\") double price) &#123; //System.out.println(\"name&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + name + \" price&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + price); log.info(\"name&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + name + \" price&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\" + price); return userService.findByName(name);&#125; 代码说明请求是key/value类型,这里不需要指定contentType，因为默认就 是key/value类型 博客中若有错误,欢迎大家指出噢,大家共同学习,共同提高,嘿嘿 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Spring","slug":"Spring","permalink":"https://zhouxu2016.github.io/categories/Spring/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://zhouxu2016.github.io/tags/Ajax/"}]},{"title":"Spring Boot整合Mybatis实现Druid多数据源","slug":"springboot-mybatis","date":"2017-12-01T13:39:38.689Z","updated":"2019-05-23T02:36:28.405Z","comments":true,"path":"2017/12/01/springboot-mybatis/","link":"","permalink":"https://zhouxu2016.github.io/2017/12/01/springboot-mybatis/","excerpt":"### 多数据源的应用场景 ###目前，业界流行的数据操作框架是 Mybatis，那 Druid 是什么呢？Druid 是 Java 的数据库连接池组件。Druid 能够提供强大的监控和扩展功能。比如可以监控 SQL ，在监控业务可以查询慢查询 SQL 列表等。Druid 核心主要包括三部分：(1) DruidDriver 代理 Driver，能够提供基于 Filter－Chain 模式的插件体系。(2) DruidDataSource 高效可管理的数据库连接池(3) SQLParser当业务数据量达到了一定程度，DBA 需要合理配置数据库资源。即配置主库的机器高配置，把核心高频的数据放在主库上；把次要的数据放在从库，低配置。开源节流,就这个意思。把数据放在不同的数据库里，就需要通过不同的数据源进行操作数据。这里我们举个 springboot-mybatis-mutil-datasource 工程案例：User 用户表在主库 master 上，地址表 city和work表分别在在从库 cluster 和cluster2上。下面实现获取根据用户名获取用户信息,地址信息,以及工作信息,使用RESTful API进行测试,从主库和从库中分别获取数据","text":"### 多数据源的应用场景 ###目前，业界流行的数据操作框架是 Mybatis，那 Druid 是什么呢？Druid 是 Java 的数据库连接池组件。Druid 能够提供强大的监控和扩展功能。比如可以监控 SQL ，在监控业务可以查询慢查询 SQL 列表等。Druid 核心主要包括三部分：(1) DruidDriver 代理 Driver，能够提供基于 Filter－Chain 模式的插件体系。(2) DruidDataSource 高效可管理的数据库连接池(3) SQLParser当业务数据量达到了一定程度，DBA 需要合理配置数据库资源。即配置主库的机器高配置，把核心高频的数据放在主库上；把次要的数据放在从库，低配置。开源节流,就这个意思。把数据放在不同的数据库里，就需要通过不同的数据源进行操作数据。这里我们举个 springboot-mybatis-mutil-datasource 工程案例：User 用户表在主库 master 上，地址表 city和work表分别在在从库 cluster 和cluster2上。下面实现获取根据用户名获取用户信息,地址信息,以及工作信息,使用RESTful API进行测试,从主库和从库中分别获取数据### 数据库准备 ####### 主数据库(Oracle) ####主数据库使用Oracle,创建CUser表,脚本如下:123456CREATE TABLE \"C##ZHOUXU\".\"CUser\" (\"id\" NUMBER NOT NULL ,\"user_name\" VARCHAR2(25 BYTE) NULL ,\"description\" VARCHAR2(200 BYTE) NULL ,PRIMARY KEY (\"id\"))插入数据,脚本如下:1insert into CUSER values(1,'zhouxu','个人博客: https://zhouxu2016.github.io/')#### 从数据库(Mysql) ####(1) 从数据库一创建数据库,springbootdb_cluster,脚本如下:1create database springbootdb_cluster;然后在数据库springbootdb_cluster下创建表city,脚本如下:1234567CREATE TABLE `city` (`id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '城市编号' ,`province_id` int(10) UNSIGNED NOT NULL COMMENT '省份编号' ,`city_name` varchar(25) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '城市名称' ,`description` varchar(25) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述' ,PRIMARY KEY (`id`))向city表插入数据,脚本如下:1insert into city values(1,1,'上海市','上海徐汇区')(2) 从数据库二创建数据库,springbootdb_cluster2,脚本如下:1create database springbootdb_cluster2;然后在数据库springbootdb_cluster下创建表work,脚本如下:1234567CREATE TABLE `work` (`id` int(11) NOT NULL ,`work_address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`company` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,PRIMARY KEY (`id`))向work表插入数据,脚本如下:1insert into work values(1,'上海徐汇区','上海互联网科技有限公司','周旭')### 项目结构介绍 ###org.spring.springboot.config.ds - 配置层，这里是数据源的配置，包括 master 和 cluster 的数据源配置org.spring.springboot.controller - Controller 层org.spring.springboot.dao - 数据操作层 DAO，细分了 master 和 cluster 包下的 DAO 操作类org.spring.springboot.domain - 实体类org.spring.springboot.service - 业务逻辑层Application - 应用启动类application.properties - 应用配置文件，应用启动会自动读取配置### Maven依赖pom.xml ###123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;springboot&lt;/groupId&gt; &lt;artifactId&gt;springboot-mybatis-mutil-datasource&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-mybatis-mutil-datasource :: Spring Boot 实现 Mybatis 多数据源配置&lt;/name&gt; &lt;!-- Spring Boot 启动父依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;mybatis-spring-boot&gt;1.2.0&lt;/mybatis-spring-boot&gt; &lt;mysql-connector&gt;5.1.39&lt;/mysql-connector&gt; &lt;druid&gt;1.0.18&lt;/druid&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Boot Web 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Test 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Mybatis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring-boot&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL 连接驱动依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql-connector&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 12. oracle --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.noraui&lt;/groupId&gt; &lt;artifactId&gt;ojdbc7&lt;/artifactId&gt; &lt;version&gt;12.1.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.4&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;!-- Druid 数据连接池依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;### application.properties 配置 ###application.properties 配置三个数据源配置,主数据源master,使用Oracle,从数据源cluster,clustertwo使用Mysql1234567891011121314151617## master 主数据源配置(oracle)master.datasource.url=jdbc:oracle:thin:@127.0.0.1:1521:ORCLmaster.datasource.username=C##zhouxumaster.datasource.password=123456master.datasource.driverClassName=oracle.jdbc.driver.OracleDriver## cluster 从数据源配置(Mysql)cluster.datasource.url=jdbc:mysql://localhost:3306/springbootdb_cluster?useUnicode=true&amp;characterEncoding=utf8cluster.datasource.username=rootcluster.datasource.password=rootcluster.datasource.driverClassName=com.mysql.jdbc.Driver## cluster 从数据源配置2(Mysql)clustertwo.datasource.url=jdbc:mysql://localhost:3306/springbootdb_cluster2?useUnicode=true&amp;characterEncoding=utf8clustertwo.datasource.username=rootclustertwo.datasource.password=rootclustertwo.datasource.driverClassName=com.mysql.jdbc.Driver### 数据源配置 ### (1) MasterDataSourceConfig 配置多数据源配置的时候注意，必须要有一个主数据源，即 MasterDataSourceConfig 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package org.spring.springboot.config.ds;import com.alibaba.druid.pool.DruidDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import javax.sql.DataSource;/** * @author zhouxu */@Configuration// 扫描Mapper接口并容器管理(相当于在所有的Mapper接口上加上@Mapper注解,可以实现依赖注入)// sqlSessionFactoryRef用来引用,数据库工厂实例对象@MapperScan(basePackages = MasterDataSourceConfig.PACKAGE, sqlSessionFactoryRef = \"masterSqlSessionFactory\")public class MasterDataSourceConfig &#123; /** * 精确到 master 目录,以便跟其他数据源隔离 */ static final String PACKAGE = \"org.spring.springboot.dao.master\"; static final String MAPPER_LOCATION = \"classpath:mapper/master/*.xml\"; @Value(\"$&#123;master.datasource.url&#125;\") private String url; @Value(\"$&#123;master.datasource.username&#125;\") private String user; @Value(\"$&#123;master.datasource.password&#125;\") private String password; @Value(\"$&#123;master.datasource.driverClassName&#125;\") private String driverClass; /** * 使用@Primary注解表明为主数据源 * * @return dataSource,数据源对象 */ @Bean(name = \"masterDataSource\") @Primary public DataSource masterDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(user); dataSource.setPassword(password); return dataSource; &#125; // 配置主数据源相关的事物管理 @Bean(name = \"masterTransactionManager\") @Primary public DataSourceTransactionManager masterTransactionManager() &#123; return new DataSourceTransactionManager(masterDataSource()); &#125; // 设置主数据源的SqlSessionFactory @Bean(name = \"masterSqlSessionFactory\") @Primary public SqlSessionFactory masterSqlSessionFactory(@Qualifier(\"masterDataSource\") DataSource masterDataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();// 设置数据源 sessionFactory.setDataSource(masterDataSource);// 设置加载Mapper接口的xml映射文件的位置 sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(MasterDataSourceConfig.MAPPER_LOCATION));// 返回数据库工厂实例对象 return sessionFactory.getObject(); &#125;&#125;@Primary 标志这个 Bean 如果在多个同类 Bean 候选时，该 Bean 优先被考虑。(多数据源配置的时候注意，必须要有一个主数据源，用 @Primary 标志该 Bean)@MapperScan 扫描 Mapper 接口并容器管理，包路径精确到 master，为了和下面 cluster 数据源做到精确区分@Value 获取全局配置文件 application.properties 的 kv 配置,并自动装配sqlSessionFactoryRef 表示定义了 key ，表示一个唯一 SqlSessionFactory 实例(2) ClusterDataSourceConfig 配置从数据源 ClusterDataSourceConfig 配置如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package org.spring.springboot.config.ds;import com.alibaba.druid.pool.DruidDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import javax.sql.DataSource;@Configuration//Spring Boot拥有嵌入式Tomcat,Spring Boot本身就集成了Tomcat// 扫描Mapper接口并容器管理(相当于在所有的Mapper接口上加上@Mapper注解,可以实现依赖注入)// sqlSessionFactoryRef用来引用,数据库工厂实例对象@MapperScan(basePackages = ClusterDataSourceConfig.PACKAGE, sqlSessionFactoryRef = \"clusterSqlSessionFactory\")public class ClusterDataSourceConfig &#123; // 精确到 cluster 目录，以便跟其他数据源隔离 static final String PACKAGE = \"org.spring.springboot.dao.cluster\"; static final String MAPPER_LOCATION = \"classpath:mapper/cluster/*.xml\"; @Value(\"$&#123;cluscter.datasoure.url&#125;\") private String url; @Value(\"$&#123;cluster.datasource.username&#125;\") private String user; @Value(\"$&#123;cluster.datasource.password&#125;\") private String password; @Value(\"$&#123;cluster.datasource.driverClassName&#125;\") private String driverClass; @Bean(name = \"clusterDataSource\") public DataSource clusterDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(user); dataSource.setPassword(password); return dataSource; &#125; // 配置从数据源相关的事物管理 @Bean(name = \"clusterTransactionManager\") public DataSourceTransactionManager clusterTransactionManager() &#123; return new DataSourceTransactionManager(clusterDataSource()); &#125; @Bean(name = \"clusterSqlSessionFactory\") public SqlSessionFactory clusterSqlSessionFactory(@Qualifier(\"clusterDataSource\") DataSource clusterDataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();// 设置数据源到SqlSessionFactory sessionFactory.setDataSource(clusterDataSource);// 设置加载Mapper接口的xml映射文件的位置 sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(ClusterDataSourceConfig.MAPPER_LOCATION));// 返回数据库工厂实例对象 return sessionFactory.getObject(); &#125;&#125;(3) WorkDataSourceConfig配置从数据源 WorkDataSourceConfig配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package org.spring.springboot.config.ds;import com.alibaba.druid.pool.DruidDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import javax.sql.DataSource;@Configuration// 扫描Mapper接口并容器管理(相当于在所有的Mapper接口上加上@Mapper注解,可以实现依赖注入)// sqlSessionFactoryRef用来引用,数据库工厂实例对象@MapperScan(basePackages = WorkDataSourceConfig.PACKAGE,sqlSessionFactoryRef = \"clusterTwoSqlSessionFactory\")public class WorkDataSourceConfig &#123; // 精确到 cluster 目录，以便跟其他数据源隔离 static final String PACKAGE = \"org.spring.springboot.dao.work\"; static final String MAPPER_LOCATION = \"classpath:mapper/work/*.xml\"; @Value(\"$&#123;clustertwo.datasource.url&#125;\") private String url; @Value(\"$&#123;clustertwo.datasource.username&#125;\") private String user; @Value(\"$&#123;clustertwo.datasource.password&#125;\") private String password; @Value(\"$&#123;clustertwo.datasource.driverClassName&#125;\") private String driverClass; @Bean(name = \"clustertwoDataSource\") public DataSource clusterDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(user); dataSource.setPassword(password); return dataSource; &#125; // 配置从数据源相关的事物管理 @Bean(name = \"clusterTwoTransactionManager\") public DataSourceTransactionManager clusterTransactionManager() &#123; return new DataSourceTransactionManager(clusterDataSource()); &#125; @Bean(name = \"clusterTwoSqlSessionFactory\") public SqlSessionFactory clusterSqlSessionFactory(@Qualifier(\"clustertwoDataSource\") DataSource clusterDataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();// 设置数据源到SqlSessionFactory sessionFactory.setDataSource(clusterDataSource);// 设置加载Mapper接口的xml映射文件的位置 sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(WorkDataSourceConfig.MAPPER_LOCATION));// 返回数据库工厂实例对象 return sessionFactory.getObject(); &#125;&#125;上面数据源配置分别扫描 Mapper 接口，org.spring.springboot.dao.master.UserDao(对应 xml classpath:mapper/master/UserMapper.xml)### 持久层 ###(1) 用户Dao接口类UserDao123456789101112131415161718192021222324package org.spring.springboot.dao.master;import org.apache.ibatis.annotations.Param;import org.spring.springboot.domain.User;/** * 用户 DAO 接口类 * *///@MapperScan(basePackages = MasterDataSourceConfig.PACKAGE,// sqlSessionFactoryRef = \"masterSqlSessionFactory\")// MasterDataSourceConfig,已经配置Mapper扫描了,这里的Mapper接口就不需要加上@Mapper注解了//@Mapperpublic interface UserDao &#123; /** * 根据用户名获取用户信息 * * @param userName * @return */ User findByName(@Param(\"userName\") String userName);&#125;UserDao对应Mapper xml文件UserMapper.xml1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" &gt;&lt;mapper namespace=\"org.spring.springboot.dao.master.UserDao\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"org.spring.springboot.domain.User\"&gt; &lt;result column=\"id\" property=\"id\" /&gt; &lt;result column=\"user_name\" property=\"userName\" /&gt; &lt;result column=\"description\" property=\"description\" /&gt; &lt;/resultMap&gt; &lt;parameterMap id=\"User\" type=\"org.spring.springboot.domain.User\"/&gt; &lt;sql id=\"Base_Column_List\"&gt; \"id\", \"user_name\", \"description\" &lt;/sql&gt; &lt;select id=\"findByName\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.String\"&gt; select &lt;include refid=\"Base_Column_List\" /&gt; from cuser where \"user_name\" = #&#123;userName&#125; &lt;/select&gt;&lt;/mapper&gt;(2) 城市Dao接口类CityDao1234567891011121314151617181920212223package org.spring.springboot.dao.cluster;import org.apache.ibatis.annotations.Param;import org.spring.springboot.domain.City;/** * 城市 DAO 接口类 * *///@MapperScan(basePackages = MasterDataSourceConfig.PACKAGE,// sqlSessionFactoryRef = \"masterSqlSessionFactory\")// MasterDataSourceConfig,已经配置Mapper扫描了,这里的Mapper接口就不需要加上@Mapper注解了//@Mapperpublic interface CityDao &#123; /** * 根据城市名称，查询城市信息 * * @param cityName 城市名 */ City findByName(@Param(\"cityName\") String cityName);&#125;CityDao对应Mapper xml文件CityMapper.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" &gt;&lt;mapper namespace=\"org.spring.springboot.dao.cluster.CityDao\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"org.spring.springboot.domain.City\"&gt; &lt;result column=\"id\" property=\"id\" /&gt; &lt;result column=\"province_id\" property=\"provinceId\" /&gt; &lt;result column=\"city_name\" property=\"cityName\" /&gt; &lt;result column=\"description\" property=\"description\" /&gt; &lt;/resultMap&gt; &lt;parameterMap id=\"City\" type=\"org.spring.springboot.domain.City\"/&gt; &lt;sql id=\"Base_Column_List\"&gt; id, province_id, city_name, description &lt;/sql&gt; &lt;select id=\"findByName\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.String\"&gt; select &lt;include refid=\"Base_Column_List\" /&gt; from city where city_name = #&#123;cityName&#125; &lt;/select&gt;&lt;/mapper&gt;(3) 城市 WorkDao 接口类WorkDao1234567891011121314151617181920package org.spring.springboot.dao.work;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.type.Alias;import org.spring.springboot.domain.Work;/** * 城市 WorkDao 接口类 * *///@MapperScan(basePackages = MasterDataSourceConfig.PACKAGE,// sqlSessionFactoryRef = \"masterSqlSessionFactory\")// MasterDataSourceConfig,已经配置Mapper扫描了,这里的Mapper接口就不需要加上@Mapper注解了//@Mapperpublic interface WorkDao &#123; Work findByName(@Param(\"name\") String name);&#125;WorkDao对应Mapper xml文件WorkMapper.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" &gt;&lt;mapper namespace=\"org.spring.springboot.dao.work.WorkDao\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"org.spring.springboot.domain.Work\"&gt; &lt;result column=\"id\" property=\"id\"/&gt; &lt;result column=\"work_address\" property=\"workAddress\"/&gt; &lt;result column=\"company\" property=\"company\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/resultMap&gt; &lt;parameterMap id=\"Work\" type=\"org.spring.springboot.domain.Work\"/&gt; &lt;sql id=\"Base_Column_List\"&gt; id, work_address, company,name &lt;/sql&gt; &lt;select id=\"findByName\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.String\"&gt; select &lt;include refid=\"Base_Column_List\"/&gt; from work where name = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt;### 业务层 ###依赖注入了三个 Dao12345678910111213141516171819202122232425262728293031323334353637383940package org.spring.springboot.service.impl;import org.spring.springboot.dao.cluster.CityDao;import org.spring.springboot.dao.master.UserDao;import org.spring.springboot.dao.work.WorkDao;import org.spring.springboot.domain.City;import org.spring.springboot.domain.User;import org.spring.springboot.domain.Work;import org.spring.springboot.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * 用户业务实现层 */@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; // 主数据源 @Autowired private CityDao cityDao; // 从数据源 @Autowired private WorkDao workDao; // 从数据源 @Override public User findByName(String userName) &#123; User user = userDao.findByName(userName); City city = cityDao.findByName(\"上海市\"); Work work = workDao.findByName(\"周旭\"); user.setCity(city); user.setWork(work); return user; &#125;&#125;### Web层 ###根据用户名获取用户信息，包括从库的地址信息12345678910111213141516171819202122232425262728package org.spring.springboot.controller;import org.spring.springboot.domain.User;import org.spring.springboot.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;/** * 用户控制层 * */@RestControllerpublic class UserRestController &#123; @Autowired private UserService userService; /** * 根据用户名获取用户信息，包括从库的地址信息 * * @param name * @return */ @GetMapping(value = \"/api/user/&#123;userName&#125;\") public User findByName(@PathVariable(value = \"userName\") String name) &#123; return userService.findByName(name); &#125;&#125;运行项目,在浏览器中输入以下地址:1http://localhost:8080/api/user/zhouxu会返回下面json串:1234567891011121314151617&#123; \"id\": 1, \"userName\": \"zhouxu\", \"description\": \"个人博客: https://zhouxu2016.github.io/\", \"city\": &#123; \"id\": 1, \"provinceId\": 1, \"cityName\": \"上海市\", \"description\": \"上海徐汇区\" &#125;, \"work\": &#123; \"id\": 1, \"workAddress\": \"上海徐汇区\", \"company\": \"上海互联网科技有限公司\", \"name\": \"周旭\" &#125;&#125;源码地址: Spring Boot整合Mybatis实现Druid多数据源### 总结 ###多数据源适合的场景很多。不同的 DataSource ,不同的 SqlSessionFactory 和不同的 DAO 层,在业务逻辑层做整合分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://zhouxu2016.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Druid","slug":"Druid","permalink":"https://zhouxu2016.github.io/tags/Druid/"}]},{"title":"Annotation自定义注解的简单使用","slug":"AnnotationUsed","date":"2017-12-01T07:28:16.939Z","updated":"2019-05-23T02:55:29.202Z","comments":true,"path":"2017/12/01/AnnotationUsed/","link":"","permalink":"https://zhouxu2016.github.io/2017/12/01/AnnotationUsed/","excerpt":"Annotation注解处理器如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。 注解处理器类库Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类： (1) Class：类定义(2) Constructor：构造器定义(3) Field：累的成员变量定义(4) Method：类的方法定义(5) Package：类的包定义","text":"Annotation注解处理器如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。 注解处理器类库Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类： (1) Class：类定义(2) Constructor：构造器定义(3) Field：累的成员变量定义(4) Method：类的方法定义(5) Package：类的包定义 java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。 AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息： 方法1： T getAnnotation(Class annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。 方法3：boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。 方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 一个简单的注解处理器： 水果名称注解:123456789101112131415package annotation;import java.lang.annotation.*;/** 水果名称注解 * Created by zhouxu on 2017/11/22 16:18. */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitName &#123;// 该注解用于修饰成员变量 public String value() default \"\";&#125; 水果颜色注解123456789101112131415161718192021package annotation;import java.lang.annotation.*;/** 水果颜色注解 * Created by zhouxu on 2017/11/22 16:23. */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitColor &#123; /** * 颜色枚举 */ public enum Color&#123;BULE,RED,GREEN&#125;; /** 颜色属性 * @return */ public Color fruitColor() default Color.BULE;&#125; 水果提供者注解123456789101112131415161718192021222324252627package annotation;import java.lang.annotation.*;/** * 水果提供者注解 * Created by zhouxu on 2017/11/22 16:42. */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitProvider &#123; /** 供应商编号 * @return */ public int id() default -1; /** 供应商名称 * @return */ public String name() default \"\"; /** 供应商地址 * @return */ public String address() default \"\";&#125; 在JavaBean中的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package annotation;/** * Created by zhouxu on 2017/11/22 16:55. */public class Apple &#123; @FruitName(\"Apple\") private String appleName; @FruitColor(fruitColor = FruitColor.Color.RED) private String appleColor; @FruitProvider(id = 1, name = \"上海红富士集团\", address = \"上海市徐汇区古美路凤凰大厦\") private String appleProvider; public Apple() &#123; &#125; public Apple(String appleName, String appleColor, String appleProvider) &#123; this.appleName = appleName; this.appleColor = appleColor; this.appleProvider = appleProvider; &#125; public String getAppleName() &#123; return appleName; &#125; public void setAppleName(String appleName) &#123; this.appleName = appleName; &#125; public String getAppleColor() &#123; return appleColor; &#125; public void setAppleColor(String appleColor) &#123; this.appleColor = appleColor; &#125; public String getAppleProvider() &#123; return appleProvider; &#125; public void setAppleProvider(String appleProvider) &#123; this.appleProvider = appleProvider; &#125; @Override public String toString() &#123; return \"Apple&#123;\" + \"appleName='\" + appleName + '\\'' + \", appleColor='\" + appleColor + '\\'' + \", appleProvider='\" + appleProvider + '\\'' + '&#125;'; &#125;&#125; 注解处理器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package annotation;import org.apache.log4j.Logger;import annotation.FruitColor.Color;import java.lang.reflect.Field;/** * 注解处理器 * Created by zhouxu on 2017/11/22 17:01. */public class FruitInfo &#123; private static Logger log = Logger.getLogger(FruitInfo.class); private static void getFruitInfo(Class&lt;?&gt; clazz) &#123;// 获取所有的成员变量包括私有属性,返回数组(getDeclaredFields()方法可以获取所有的成员变量)// 通过反射机制获取类的私有成员变量 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; log.info(\"field.getName()&gt;&gt;&gt;&gt;&gt;\" + field.getName()); log.info(\"log.info(field.getAnnotatedType())&gt;&gt;&gt;&gt;&gt;\" + field.getAnnotatedType()); log.info(\"field.getAnnotations()&gt;&gt;&gt;&gt;&gt;\" + field.getAnnotations()); log.info(\"field.getDeclaredAnnotations()\" + field.getDeclaredAnnotations()); log.info(\"fields&gt;&gt;&gt;&gt;&gt;\" + field); &#125; for (Field field : fields) &#123; if (field.isAnnotationPresent(FruitName.class)) &#123; FruitName fruitName = field.getAnnotation(FruitName.class); String value = fruitName.value(); log.info(\"水果名称&gt;&gt;&gt;&gt;&gt;\" + value); &#125; else if (field.isAnnotationPresent(FruitColor.class)) &#123; FruitColor fruitColor = field.getAnnotation(FruitColor.class); Color color = fruitColor.fruitColor(); log.info(\"水果颜色&gt;&gt;&gt;&gt;&gt;\" + color.toString()); &#125; else if (field.isAnnotationPresent(FruitProvider.class)) &#123; FruitProvider fruitProvider = field.getAnnotation(FruitProvider.class); int id = fruitProvider.id(); String name = fruitProvider.name(); String address = fruitProvider.address(); log.info(\"供应商编号&gt;&gt;&gt;&gt;&gt;\" + id + \" 供应商名称&gt;&gt;&gt;&gt;&gt;\" + name + \" 供应商地址&gt;&gt;&gt;&gt;&gt;\" + address); &#125; &#125; &#125; public static void main(String[] args) &#123; FruitInfo.getFruitInfo(Apple.class); &#125;&#125; 输出结果123456782017-12-01 16:14:38,308 [main] INFO [annotation.FruitInfo] - field.getName()&gt;&gt;&gt;appleName2017-12-01 16:14:38,308 [main] INFO [annotation.FruitInfo] - field.getName()&gt;&gt;&gt;appleColor2017-12-01 16:14:38,308 [main] INFO [annotation.FruitInfo] - field.getName()&gt;&gt;&gt;appleProvider2017-12-01 16:14:38,324 [main] INFO [annotation.FruitInfo] - 水果名称&gt;&gt;&gt;Apple2017-12-01 16:14:38,340 [main] INFO [annotation.FruitInfo] - 水果颜色&gt;&gt;&gt;RED2017-12-01 16:14:38,340 [main] INFO [annotation.FruitInfo] - 供应商编号&gt;&gt;&gt;1 供应商名称&gt;&gt;&gt;上海红富士集团 供应商地址&gt;&gt;&gt;上海市徐汇区古美路凤凰大厦Process finished with exit code 0 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Annotation","slug":"Annotation","permalink":"https://zhouxu2016.github.io/tags/Annotation/"}]},{"title":"Annotation自定义注解的简单介绍","slug":"Annotation","date":"2017-12-01T06:33:06.967Z","updated":"2019-05-23T02:57:00.749Z","comments":true,"path":"2017/12/01/Annotation/","link":"","permalink":"https://zhouxu2016.github.io/2017/12/01/Annotation/","excerpt":"Annotation自定义注解元注解的介绍在学习自定义注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。 元注解：元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解： (1) @Target(2) @Retention(3) @Documented(4) @Inherited 这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。 @Target@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）","text":"Annotation自定义注解元注解的介绍在学习自定义注解之前，我们就必须要了解Java为我们提供的元注解和相关定义注解的语法。 元注解：元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解： (1) @Target(2) @Retention(3) @Documented(4) @Inherited 这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。 @Target@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有: (1) CONSTRUCTOR:用于描述构造器(2) FIELD:用于描述域(3) LOCAL_VARIABLE:用于描述局部变量(4) METHOD:用于描述方法(5) PACKAGE:用于描述包(6) PARAMETER:用于描述参数(7) TYPE:用于描述类、接口(包括注解类型) 或enum声明 使用实例: 12345678910111213@Target(ElementType.TYPE)public @interface Table &#123; /** * 数据表名称注解，默认值为类名称 * @return */ public String tableName() default \"className\";&#125;@Target(ElementType.FIELD)public @interface NoDBColumn &#123;&#125; 注解Table 可以用于注解类、接口(包括注解类型) 或enum声明,而注解NoDBColumn仅可用于注解类的成员变量。 @Retention@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPoicy）有: (1) SOURCE:在源文件中有效（即源文件保留）(2) CLASS:在class文件中有效（即class保留）(3) RUNTIME:在运行时有效（即运行时保留） Retention meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。具体实例如下: 12345678@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; public String name() default \"fieldName\"; public String setFuncName() default \"setField\"; public String getFuncName() default \"getField\"; public boolean defaultDBValue() default false;&#125; Column注解的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理 @Documented@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 123456789@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Column &#123; public String name() default \"fieldName\"; public String setFuncName() default \"setField\"; public String getFuncName() default \"getField\"; public boolean defaultDBValue() default false;&#125; @Inherited@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 实例代码： 12345678910/** * *Created by zhouxu on 2017/11/22 17:01. */@Inheritedpublic @interface Greeting &#123; public enum FontColor&#123; BULE,RED,GREEN&#125;; String name(); FontColor fontColor() default FontColor.GREEN;&#125; 自定义注解的定义使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 定义注解格式: public @interface 注解名 {定义体} 注解参数的可支持数据类型: (1) 所有基本数据类型（int,float,boolean,byte,double,char,long,short)(2) String类型(3) Class类型(4) enum类型(5) Annotation类型(6) 以上所有类型的数组 Annotation类型里面的参数该怎么设定: 第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型 第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String 第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.例:下面的例子FruitName注解就只有一个参数成员。 简单的自定义注解和使用注解实例: 水果名称注解:123456789101112131415package annotation;import java.lang.annotation.*;/** 水果名称注解 * Created by zhouxu on 2017/11/22 16:18. */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitName &#123;// 该注解用于修饰成员变量 public String value() default \"\";&#125; 水果颜色注解123456789101112131415161718192021package annotation;import java.lang.annotation.*;/** 水果颜色注解 * Created by zhouxu on 2017/11/22 16:23. */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitColor &#123; /** * 颜色枚举 */ public enum Color&#123;BULE,RED,GREEN&#125;; /** 颜色属性 * @return */ public Color fruitColor() default Color.BULE;&#125; 水果提供者注解注解元素的默认值: 注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。例如： 123456789101112131415161718192021222324252627package annotation;import java.lang.annotation.*;/** * 水果提供者注解 * Created by zhouxu on 2017/11/22 16:42. */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitProvider &#123; /** 供应商编号 * @return */ public int id() default -1; /** 供应商名称 * @return */ public String name() default \"\"; /** 供应商地址 * @return */ public String address() default \"\";&#125; 在JavaBean中的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package annotation;/** * Created by zhouxu on 2017/11/22 16:55. */public class Apple &#123; @FruitName(\"Apple\") private String appleName; @FruitColor(fruitColor = FruitColor.Color.RED) private String appleColor; @FruitProvider(id = 1, name = \"上海红富士集团\", address = \"上海市徐汇区古美路凤凰大厦\") private String appleProvider; public Apple() &#123; &#125; public Apple(String appleName, String appleColor, String appleProvider) &#123; this.appleName = appleName; this.appleColor = appleColor; this.appleProvider = appleProvider; &#125; public String getAppleName() &#123; return appleName; &#125; public void setAppleName(String appleName) &#123; this.appleName = appleName; &#125; public String getAppleColor() &#123; return appleColor; &#125; public void setAppleColor(String appleColor) &#123; this.appleColor = appleColor; &#125; public String getAppleProvider() &#123; return appleProvider; &#125; public void setAppleProvider(String appleProvider) &#123; this.appleProvider = appleProvider; &#125; @Override public String toString() &#123; return \"Apple&#123;\" + \"appleName='\" + appleName + '\\'' + \", appleColor='\" + appleColor + '\\'' + \", appleProvider='\" + appleProvider + '\\'' + '&#125;'; &#125;&#125; 定义了注解，并在需要的时候给相关类，类属性加上注解信息，如果没有响应的注解信息处理流程，注解可以说是没有实用价值。如何让注解真正的发挥作用，主要就在于注解处理方法，下一步我们将学习注解信息的获取和处理 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Annotation","slug":"Annotation","permalink":"https://zhouxu2016.github.io/tags/Annotation/"}]},{"title":"ConcurrentHashMap的简单使用","slug":"ConcurrentHashMap","date":"2017-11-27T14:37:26.960Z","updated":"2019-05-23T02:55:17.093Z","comments":true,"path":"2017/11/27/ConcurrentHashMap/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/27/ConcurrentHashMap/","excerpt":"ConcurrentHashMap的介绍ConcurrentHashMap是一个线程安全，并且是一个高效的HashMap,ConcurrentMap，它是一个接口，是一个能够支持并发访问的java.util.map集合,在原有java.util.map接口基础上又新提供了4种方法，进一步扩展了原有Map的功能 1234567891011121314public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; //插入元素 V putIfAbsent(K key, V value); //移除元素 boolean remove(Object key, Object value); //替换元素 boolean replace(K key, V oldValue, V newValue); //替换元素 V replace(K key, V value);&#125; (1) putIfAbsent: 与原有put方法不同的是,putIfAbsent方法中如果插入的key相同,则不替换原有的value值 (2) remove: 与原有remove方法不同的是,新remove方法中增加了对value的判断,如果要删除的key–value不能与Map中原有的key–value对应上,则不会删除该元素 (3) replace(K,V,V): 增加了对value值的判断,如果key–oldValue能与Map中原有的key–value对应上,才进行替换操作 (4) replace(K,V): 与上面的replace不同的是,此replace不会对Map中原有的key–value进行比较,如果key存在则直接替换","text":"ConcurrentHashMap的介绍ConcurrentHashMap是一个线程安全，并且是一个高效的HashMap,ConcurrentMap，它是一个接口，是一个能够支持并发访问的java.util.map集合,在原有java.util.map接口基础上又新提供了4种方法，进一步扩展了原有Map的功能 1234567891011121314public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123; //插入元素 V putIfAbsent(K key, V value); //移除元素 boolean remove(Object key, Object value); //替换元素 boolean replace(K key, V oldValue, V newValue); //替换元素 V replace(K key, V value);&#125; (1) putIfAbsent: 与原有put方法不同的是,putIfAbsent方法中如果插入的key相同,则不替换原有的value值 (2) remove: 与原有remove方法不同的是,新remove方法中增加了对value的判断,如果要删除的key–value不能与Map中原有的key–value对应上,则不会删除该元素 (3) replace(K,V,V): 增加了对value值的判断,如果key–oldValue能与Map中原有的key–value对应上,才进行替换操作 (4) replace(K,V): 与上面的replace不同的是,此replace不会对Map中原有的key–value进行比较,如果key存在则直接替换 12345678910111213141516171819202122232425262728 private static Logger log = Logger.getLogger(ConcurrentMapDemo.class); @Test public void test() &#123; ConcurrentHashMap&lt;Object, Object&gt; concurrentHashMap = new ConcurrentHashMap&lt;Object, Object&gt;(); concurrentHashMap.put(\"name\", \"tom\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString());// putIfAbsent: 与原有put方法不同的是,putIfAbsent方法中如果插入的key相同,则不替换原有的value值 concurrentHashMap.putIfAbsent(\"name\", \"lucy\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString());// remove: 与原有remove方法不同的是,新remove方法中增加了对value的判断,如果要删除的key--value不能与Map中原有的key--value对应上,// 则不会删除该元素 concurrentHashMap.remove(\"name\", \"lucy\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString());// replace(K,V,V): 增加了对value值的判断,如果key--oldValue能与Map中原有的key--value对应上,才进行替换操作 concurrentHashMap.replace(\"name\", \"lucy\", \"newLucy\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString());// replace(K,V): 与上面的replace不同的是,此replace不会对Map中原有的key--value进行比较,如果key存在则直接替换 concurrentHashMap.replace(\"name\", \"lucy\"); log.info(\"concurrentHashMap&gt;&gt;&gt;&gt;&gt; \" + concurrentHashMap.toString()); &#125; 其实,对于ConcurrentMap来说,我们更关注Map本身的操作,在并发情况下是如何实现数据安全的。在java.util.concurrent包中,ConcurrentMap的实现类主要以ConcurrentHashMap为主,接下来,我们具体来看下 从线程安全的角度来说,HashTable已经是一个线程安全的HashMap,说起ConcurrentHashMap,就不得不先提及下HashMap在线程不安全的表现 HashMap遍历删除HashMap或者ArrayList边遍历边删除数据会报java.util.ConcurrentModificationException异常 12345678910111213141516171819@Testpublic void test() &#123; Map&lt;Long, String&gt; mReqPacket = new HashMap&lt;Long, String&gt;(); for (long i = 0; i &lt; 15; i++) &#123; mReqPacket.put(i, i + \"\"); &#125; for (Entry&lt;Long, String&gt; entry : mReqPacket.entrySet()) &#123; long key = entry.getKey(); String value = entry.getValue(); if (key &lt; 10) &#123; mReqPacket.remove(key); &#125; &#125; for (Entry&lt;Long, String&gt; entry : mReqPacket.entrySet()) &#123; log.info(entry.getKey() + \" \" + entry.getValue()); &#125;&#125; 运行结果: 1234567891011java.util.ConcurrentModificationException at java.util.HashMap$HashIterator.nextNode(HashMap.java:1437) at java.util.HashMap$EntryIterator.next(HashMap.java:1471) at java.util.HashMap$EntryIterator.next(HashMap.java:1469) at map.ConcurrentMapDemo.test1(ConcurrentMapDemo.java:119) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:389)Process finished with exit code -1 使用迭代器删除元素,没有问题,不会出现异常 : 12345678910111213141516171819@Testpublic void test() &#123; Map&lt;Long, String&gt; mReqPacket = new HashMap&lt;Long, String&gt;(); for (long i = 0; i &lt; 15; i++) &#123; mReqPacket.put(i, i + \"\"); &#125; for (Iterator&lt;Entry&lt;Long, String&gt;&gt; iterator = mReqPacket.entrySet().iterator(); iterator.hasNext();) &#123; Entry&lt;Long, String&gt; entry = iterator.next(); long key = entry.getKey(); if (key &lt; 10) &#123; iterator.remove(); &#125; &#125; for (Entry&lt;Long, String&gt; entry : mReqPacket.entrySet()) &#123; log.info(entry.getKey() + \" \" + entry.getValue()); &#125;&#125; ConcurrentHashMap允许一边更新、一边遍历，也就是说在Iterator对象遍历的时候，ConcurrentHashMap也可以进行remove,put操作，且遍历的数据会随着remove,put操作产出变化 123456789101112131415161718@Testpublic void test1() &#123; Map&lt;Long, String&gt; conMap = new ConcurrentHashMap&lt;Long, String&gt;(); for (long i = 0; i &lt; 15; i++) &#123; conMap.put(i, i + \"\"); &#125; for (Entry&lt;Long, String&gt; entry : conMap.entrySet()) &#123; long key = entry.getKey(); if (key &lt; 10) &#123; conMap.remove(key); &#125; &#125; for (Entry&lt;Long, String&gt; entry : conMap.entrySet()) &#123; log.info(entry.getKey() + \" \" + entry.getValue()); &#125;&#125; ConcurrentHashMap多线程操作对ConcurrentHashMap边遍历边删除或者增加操作不会产生异常(可以不用迭代方式删除元素)，因为其内部已经做了维护，遍历的时候都能获得最新的值。即便是多个线程一起删除、添加元素也没问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344static Map&lt;Long, String&gt; conMap = new ConcurrentHashMap&lt;Long, String&gt;();public static void main(String[] args) throws InterruptedException &#123; for (long i = 0; i &lt; 5; i++) &#123; conMap.put(i, i + \"\"); &#125; Thread thread = new Thread(new Runnable() &#123; public void run() &#123; for (Iterator&lt;Entry&lt;Long, String&gt;&gt; iterator = conMap.entrySet().iterator(); iterator.hasNext();) &#123; Map.Entry&lt;Long, String&gt; entry = iterator.next(); log.info(entry.getKey() + \" - \" + entry.getValue()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); Thread thread2 = new Thread(new Runnable() &#123; public void run() &#123; conMap.put(100l, \"100\"); log.info(\"ADD:\" + 100); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); thread.start(); thread2.start(); Thread.sleep(3000); log.info(\"--------\"); for (Map.Entry&lt;Long, String&gt; entry : conMap.entrySet()) &#123; log.info(entry.getKey() + \" \" + entry.getValue()); &#125;&#125; 输出结果 123456789101112131415162017-11-27 22:03:45,123 [Thread-0] INFO [map.ConcurrentMapDemo] - 0 - 02017-11-27 22:03:45,123 [Thread-1] INFO [map.ConcurrentMapDemo] - ADD:1002017-11-27 22:03:45,248 [Thread-0] INFO [map.ConcurrentMapDemo] - 1 - 12017-11-27 22:03:45,357 [Thread-0] INFO [map.ConcurrentMapDemo] - 2 - 22017-11-27 22:03:45,466 [Thread-0] INFO [map.ConcurrentMapDemo] - 3 - 32017-11-27 22:03:45,575 [Thread-0] INFO [map.ConcurrentMapDemo] - 4 - 42017-11-27 22:03:45,685 [Thread-0] INFO [map.ConcurrentMapDemo] - 100 - 1002017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - --------2017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 0 02017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 1 12017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 2 22017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 3 32017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 4 42017-11-27 22:03:48,135 [main] INFO [map.ConcurrentMapDemo] - 100 100Process finished with exit code 0 ConcurrentHashMap结构我们来了解下ConcurrentHashMap的整体结构，这样有利于我们快速理解源码。我们就在此进行回顾下 HashMap的整体结构 HashMap底层使用数组和链表，实现哈希表结构。插入的元素通过散列的形式分布到数组的各个角标下；当有重复的散列值时，便将新增的元素插入在链表头部，使其形成链表结构，依次向后排列。 下面是，ConcurrentHashMap的结构: 与HashMap不同的是，ConcurrentHashMap中多了一层数组结构，由Segment和HashEntry两个数组组成。其中Segment起到了加锁同步的作用，而HashEntry则起到了存储K.V键值对的作用 在ConcurrentHashMap中，每一个ConcurrentHashMap都包含了一个Segment数组，在Segment数组中每一个Segment对象则又包含了一个HashEntry数组，而在HashEntry数组中，每一个HashEntry对象保存K-V数据的同时又形成了链表结构，此时与HashMap结构相同 12345678910111213141516171819202122232425262728293031323334private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // For serialization compatibility // Emulate segment calculation from previous version of this class int sshift = 0; int ssize = 1; while (ssize &lt; DEFAULT_CONCURRENCY_LEVEL) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; int segmentShift = 32 - sshift; int segmentMask = ssize - 1; @SuppressWarnings(\"unchecked\") Segment&lt;K,V&gt;[] segments = (Segment&lt;K,V&gt;[]) new Segment&lt;?,?&gt;[DEFAULT_CONCURRENCY_LEVEL]; for (int i = 0; i &lt; segments.length; ++i) segments[i] = new Segment&lt;K,V&gt;(LOAD_FACTOR); s.putFields().put(\"segments\", segments); s.putFields().put(\"segmentShift\", segmentShift); s.putFields().put(\"segmentMask\", segmentMask); s.writeFields(); Node&lt;K,V&gt;[] t; if ((t = table) != null) &#123; Traverser&lt;K,V&gt; it = new Traverser&lt;K,V&gt;(t, t.length, 0, t.length); for (Node&lt;K,V&gt; p; (p = it.advance()) != null; ) &#123; s.writeObject(p.key); s.writeObject(p.val); &#125; &#125; s.writeObject(null); s.writeObject(null); segments = null; // throw away &#125; 在多线程中，每一个Segment对象守护了一个HashEntry数组，当对ConcurrentHashMap中的元素修改时，在获取到对应的Segment数组角标后，都会对此Segment对象加锁，之后再去操作后面的HashEntry元素，这样每一个Segment对象下，都形成了一个小小的HashMap，在保证数据安全性的同时，又提高了同步的效率。只要不是操作同一个Segment对象的话，就不会出现线程等待的问题 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Collection","slug":"Collection","permalink":"https://zhouxu2016.github.io/tags/Collection/"}]},{"title":"CopyOnWriteArrayList的简单使用","slug":"CopyOnWriteArrayList","date":"2017-11-26T03:46:04.145Z","updated":"2019-05-23T02:33:37.559Z","comments":true,"path":"2017/11/26/CopyOnWriteArrayList/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/26/CopyOnWriteArrayList/","excerpt":"CopyOnWriteArrayList的介绍CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的, 一般在多线程操作时，一个线程对list进行修改。一个线程对list进行foreach时会出现, java.util.ConcurrentModificationException错误。 下面来看一个列子：两个线程,一个线程foreach,一个线程修改list的值。 读线程123456789101112131415161718/** * 读线程 */private static class ReadTask implements Runnable &#123; List&lt;String&gt; list; public ReadTask(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; for (String str : list) &#123; log.info(\"ReadTask&gt;&gt;&gt;&gt;&gt;\" + str); &#125; &#125;&#125;","text":"CopyOnWriteArrayList的介绍CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的, 一般在多线程操作时，一个线程对list进行修改。一个线程对list进行foreach时会出现, java.util.ConcurrentModificationException错误。 下面来看一个列子：两个线程,一个线程foreach,一个线程修改list的值。 读线程123456789101112131415161718/** * 读线程 */private static class ReadTask implements Runnable &#123; List&lt;String&gt; list; public ReadTask(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; for (String str : list) &#123; log.info(\"ReadTask&gt;&gt;&gt;&gt;&gt;\" + str); &#125; &#125;&#125; 写线程1234567891011121314151617181920/** * 写线程 */private static class WriteTask implements Runnable &#123; private int index; private List&lt;String&gt; list; public WriteTask(int index, List&lt;String&gt; list) &#123; this.index = index; this.list = list; &#125; @Override public void run() &#123; list.remove(index); list.add(index, \"write&gt;&gt;\" + index); &#125;&#125; 运行代码1234567891011121314151617181920212223242526272829 private void run() &#123; final int NUM = 10; List&lt;String&gt; list = new ArrayList&lt;String&gt;();// List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for (int i = 0; i &lt; NUM; i++) &#123; list.add(\"main_\" + i); &#125;// 创建指定线程数量的线程池 ExecutorService executorService = Executors.newFixedThreadPool(NUM); for (int i = 0; i &lt; NUM; i++) &#123; executorService.execute(new ReadTask(list)); executorService.execute(new WriteTask(i, list)); &#125;// 等待线程任务执行结束之后,关闭线程// executorService.shutdown();// 立即关闭所有线程(即便是正在执行线程任务的线程,但结果不一定能够成功关闭) executorService.shutdownNow(); &#125; public static void main(String[] args) &#123;// java.util.ConcurrentModificationException,修改并发异常 new CopyOnWriteArrayListDemo().run(); &#125; 运行结果 从结果中可以看出来。在多线程情况下报错。其原因就是多线程操作结果：那这个种方案不行我们就换个方案。用jdk自带的类CopyOnWriteArrayList来做容器。 换了种方案看代码 : 123 final int NUM = 10;// List&lt;String&gt; list = new ArrayList&lt;String&gt;(); List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); 运行上面的代码,没有报出,java.util.ConcurrentModificationException异常,说明了CopyOnWriteArrayList并发多线程的环境下,仍然能很好的工作 CopyOnWriteArrayList源码分析CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。 当有新元素加入的时候，如下图，创建新数组，并往新数组中加入一个新元素,这个时候，array这个引用仍然是指向原数组的。 当元素在新数组添加成功后，将array这个引用指向新数组。 CopyOnWriteArrayList的整个add操作都是在锁的保护下进行的,这样做是为了避免在多线程并发add的时候，复制出多个副本出来,把数据搞乱了，导致最终的数组数据不是我们期望的。 CopyOnWriteArrayList的add()方法操作的源代码如下: 12345678910111213141516171819public boolean add(E e) &#123; //1、先加锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; //2、拷贝数组 Object[] newElements = Arrays.copyOf(elements, len + 1); //3、将元素加入到新数组中 newElements[len] = e; //4、将array引用指向到新数组 setArray(newElements); return true; &#125; finally &#123; //5、解锁 lock.unlock(); &#125;&#125; 由于所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况: (1) 如果写操作未完成，那么直接读取原数组的数据；(2) 如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据；(3) 如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。 可见，CopyOnWriteArrayList的读操作是可以不用加锁的。 CopyOnWriteArrayList的使用场景通过上面的分析，CopyOnWriteArrayList 有几个缺点： (1) 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc(2) 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求； CopyOnWriteArrayList 合适读多写少的场景，不过这类慎用,因为谁也没法保证CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次add/set都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。 CopyOnWriteArrayList总结如上面的分析CopyOnWriteArrayList表达的一些思想: (1) 读写分离，读和写分开(2) 最终一致性(3) 使用另外开辟空间的思路，来解决并发冲突 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Collection","slug":"Collection","permalink":"https://zhouxu2016.github.io/tags/Collection/"}]},{"title":"ExecutorService的理解与简单使用","slug":"ExecutorService","date":"2017-11-23T07:54:11.375Z","updated":"2019-05-23T02:34:08.394Z","comments":true,"path":"2017/11/23/ExecutorService/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/23/ExecutorService/","excerpt":"ExecutorService的简介接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的ExecutorService的实现就是一个线程池的实现ExecutorService的实现由于 ExecutorService 只是一个接口，你如果需要使用它，那麽就需要提供一个该接口的实现。ExecutorService 接口在 java.util.concurrent 包中有如下实现类： 这里我简单使用其中2个实现类 ThreadPoolExecutor ScheduledThreadPoolExecutor","text":"ExecutorService的简介接口 java.util.concurrent.ExecutorService 表述了异步执行的机制，并且可以让任务在后台执行。一个ExecutorService 实例因此特别像一个线程池。事实上，在 java.util.concurrent 包中的ExecutorService的实现就是一个线程池的实现ExecutorService的实现由于 ExecutorService 只是一个接口，你如果需要使用它，那麽就需要提供一个该接口的实现。ExecutorService 接口在 java.util.concurrent 包中有如下实现类： 这里我简单使用其中2个实现类 ThreadPoolExecutor ScheduledThreadPoolExecutor ExecutorService样例这里有一个简单的使用Java 实现的 ExectorService 样例: 首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService ，创建了一个可以容纳10个线程任务的线程池。其次，向 execute() 方法中传递一个异步的 Runnable 接口的实现，这样做会让 ExecutorService 中的某个线程执行这个Runnable 线程 1234567891011121314 @Test public void executeRunnable() &#123;// 创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 异步执行线程任务 executorService2.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;);// 等待所有的线程执行线程任务完毕后,关闭线程 executorService2.shutdown(); &#125; 任务的委托(Task Delegation)下方展示了一个线程的把任务委托异步执行的ExecutorService的示意图。 一旦线程把任务委托给 ExecutorService，该线程就会继续执行与运行任务无关的其它任务。 创建一个ExecutorService你可以根据自己的需要来创建一个 ExecutorService ，也可以使用 Executors 工厂方法来创建一个 ExecutorService 实例。这里有几个创建 ExecutorService 的例子: 123456789101112131415161718 private ExecutorService executorService1; private ExecutorService executorService2; private ScheduledExecutorService executorService3; private static Logger log = Logger.getLogger(ExecutorDemo.class); @BeforeEach private void studyExecutor() &#123;// 创建线程池的三种方式// 1.创建SingleThread,创建一个线程的线程池 executorService1 = Executors.newSingleThreadExecutor();// 2.创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 3.创建周期性线程池 executorService3 = Executors.newScheduledThreadPool(10); &#125; ExecutorService使用方法这里有几种不同的方式让你将任务委托给一个 ExecutorService： 12345execute(new Runnable() &#123;&#125;)submit(new Runnable() &#123;&#125;)submit(new Callable&lt;Object&gt;() &#123;&#125;)invokeAny(...)invokeAll(...) 接下来把每個方法都试试看 execute(Runnable)方法 execute(Runnable) 接收一个 java.lang.Runnable 对象作为参数，并且以异步的方式执行它。如下是一个使用 ExecutorService 执行 Runnable 的例子： 1234567891011121314@Test public void executeRunnable() &#123;// 创建固定线程数量的线程池 executorService2 = Executors.newFixedThreadPool(10);// 异步执行线程任务 executorService2.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;);// 等待所有的线程执行线程任务完毕后,关闭线程 executorService2.shutdown(); &#125; 使用这种方式没有办法获取执行 Runnable 之后的结果，如果你希望获取运行之后的返回值，就必须使用接收 Callable 参数的 execute() 方法，后者将会在下文中提到。 submit(Runnable)方法 submit(Runnable) 同样接收一个 Runnable 的实现作为参数，但是会返回一个 Future 对象。这個 Future 对象可以用于判断 Runnable 是否结束执行。如下是一个 ExecutorService 的 submit() 方法的例子： 12345678910111213141516171819 @Test public void submitRunnable() &#123; Future&lt;?&gt; future = executorService2.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;); try &#123;// 如果任务执行结束则返回null System.out.println(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;\" + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown(); &#125; submit(Callable)方法 submit(Callable) 和方法 submit(Runnable) 比较类似，但是区别则在于它们接收不同的参数类型。Callable 的实例与 Runnable 的实例很类似，但是 Callable 的 call() 方法可以返回一个结果。方法 Runnable.run() 则不能返回结果。 Callable 的返回值可以从方法 submit(Callable) 返回的 Future 对象中获取。如下是一个 ExecutorService Callable 的样例： 12345678910111213141516171819 @Test public void submitCallableRunnable() &#123; Future&lt;Object&gt; future = executorService2.submit(new Callable&lt;Object&gt;() &#123;// 使用Callable接口可以返回一个结果 @Override public Object call() throws Exception &#123; return \"Callable Result\"; &#125; &#125;); try &#123;// 获取Callable接口中call()方法的返回结果 System.out.println(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown(); &#125; 上述样例代码会输出如下结果： 12future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Callable ResultProcess finished with exit code 0 inVokeAny()方法 invokeAny() 接收一个包含 Callable 对象的集合作为参数。调用该方法不会返回 Future 对象，而是返回集合中某一个 Callable 对象的结果，而且无法保证调用之后返回的结果是哪一个 Callable，只知道它是这些 Callable 中一个执行结束的 Callable 对象。如果一个任务运行完毕或者抛出异常，方法会取消其它的 Callable 的执行。以下是一个样例： 123456789101112131415161718192021222324252627282930313233343536@Testpublic void inVokeAnyRunnable() &#123; List&lt;Callable&lt;String&gt;&gt; callableList = new ArrayList&lt;Callable&lt;String&gt;&gt;(); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task1\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task2\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task3\"; &#125; &#125;); try &#123; String result = executorService2.invokeAny(callableList); log.info(\"result&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown();&#125; 以上样例代码会打印出在给定的集合中的某一个 Callable 的返回结果。我尝试运行了几次，结果都在改变。有时候返回结果是”Task 1”，有时候是”Task 2”，等等。 invokeAll()方法 invokeAll() 会调用存在于参数集合中的所有 Callable 对象，并且返回一个包含 Future 对象的集合，你可以通过这个返回的集合来管理每个 Callable 的执行结果。需要注意的是，任务有可能因为异常而导致运行结束，所以它可能并不是真的成功运行了。但是我们没有办法通过 Future 对象来了解到这个差异。以下是一个代码样例： 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void inVokeAllRunnable() &#123; List&lt;Callable&lt;String&gt;&gt; callableList = new ArrayList&lt;Callable&lt;String&gt;&gt;(); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task1\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task2\"; &#125; &#125;); callableList.add(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return \"Task3\"; &#125; &#125;); try &#123; List&lt;Future&lt;String&gt;&gt; futureList = executorService2.invokeAll(callableList); for (Future&lt;String&gt; future : futureList) &#123; log.info(\"future.get()&gt;&gt;&gt;&gt;&gt;&gt;&gt; \" + future.get()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; executorService2.shutdown();&#125; ExecuteService服务的关闭当使用 ExecutorService 完毕之后，我们应该关闭它，这样才能保证线程不会继续保持运行状态。举例来说，如果你的程序通过 main() 方法启动，并且主线程退出了你的程序，如果你还有一个活动的 ExecutorService 存在于你的程序中，那么程序将会继续保持运行状态。存在于 ExecutorService 中的活动线程会阻止Java虚拟机关闭。为了关闭在 ExecutorService 中的线程，你需要调用 shutdown() 方法。ExecutorService 并不会马上关闭，而是不再接收新的任务，一旦所有的线程结束执行当前任务，ExecutorServie 才会真的关闭。所有在调用 shutdown() 方法之前提交到 ExecutorService 的任务都会执行。如果你希望立即关闭 ExecutorService，你可以调用 shutdownNow() 方法。这个方法会尝试马上关闭所有正在执行的任务，并且跳过所有已经提交但是还没有运行的任务。但是对于正在执行的任务，是否能够成功关闭它是无法保证的，有可能他们真的被关闭掉了，也有可能它会一直执行到任务结束。这是一个最好的尝试。 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://zhouxu2016.github.io/tags/Thread/"}]},{"title":"Java创建线程的三种方式简介","slug":"ThreadCreate","date":"2017-11-22T09:53:28.107Z","updated":"2019-05-23T02:37:17.481Z","comments":true,"path":"2017/11/22/ThreadCreate/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/22/ThreadCreate/","excerpt":"Java中创建线程主要有三种方式: 1.继承Thread类创建线程类 2.通过Runnable接口创建线程类 3.通过Callable和Future创建线程 继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。","text":"Java中创建线程主要有三种方式: 1.继承Thread类创建线程类 2.通过Runnable接口创建线程类 3.通过Callable和Future创建线程 继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。 123456789// 第一种创建线程的方式 new Thread() &#123; @Override public void run() &#123; super.run(); System.out.println(\"创建线程1&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125;.start(); 上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字 通过Runnable接口创建线程类（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动该线程。 12345678// 第二种创建线程的方式 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"创建线程2&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125;).start(); 通过Callable和Future创建线程（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 12345678910111213141516171819202122// 第三种创建线程的方式 CallableThreadTest callableThreadTest = new CallableThreadTest(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(callableThreadTest); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + \" 的循环变量i的值\" + i); if (i == 20) &#123; new Thread(futureTask, \"有返回值的线程\").start(); System.out.println(\"i == 20,当前线程&gt;&gt;&gt;&gt;&gt;&gt;\" + Thread.currentThread().getName()); &#125; &#125; try &#123;// 100 System.out.println(\"子线程的返回值&gt;&gt;&gt;&gt;&gt;\" + futureTask.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; 创建线程的三种方式的对比1.采用实现Runnable、Callable接口的方式创见多线程时， 优势是：线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是：编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 2.使用继承Thread类的方式创建多线程时 优势是：编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是：线程类已经继承了Thread类，所以不能再继承其他父类。 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Java","slug":"Java","permalink":"https://zhouxu2016.github.io/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://zhouxu2016.github.io/tags/Thread/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-03T06:57:13.240Z","updated":"2017-11-23T04:50:38.076Z","comments":true,"path":"2017/11/03/hello-world/","link":"","permalink":"https://zhouxu2016.github.io/2017/11/03/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 分享 新浪微博 QQ空间 QQ好友 豆瓣 Facebook Twitter 取消","categories":[{"name":"Study","slug":"Study","permalink":"https://zhouxu2016.github.io/categories/Study/"}],"tags":[{"name":"Study","slug":"Study","permalink":"https://zhouxu2016.github.io/tags/Study/"}]}]}